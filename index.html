<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Step By Step Game</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#6366f1',
                        secondary: '#8b5cf6',
                        accent: '#f59e0b',
                        ice: '#00d2ff',
                    }
                }
            }
        }
    </script>
    <style>
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        @keyframes pulseGlow { 0%, 100% { box-shadow: 0 0 10px rgba(0,210,255,0.3); } 50% { box-shadow: 0 0 30px rgba(0,210,255,0.8); } }
        @keyframes readyPulse { 0%, 100% { box-shadow: 0 0 10px rgba(0,255,100,0.3); } 50% { box-shadow: 0 0 30px rgba(0,255,100,0.8); } }
        .pulse-glow { animation: pulseGlow 2s ease-in-out infinite; }
        .ready-glow { animation: readyPulse 1.5s ease-in-out infinite; }
        
        .roulette-container { position: relative; width: 100%; height: 160px; overflow: hidden; background: rgba(0,0,0,0.4); border-radius: 16px; border: 2px solid rgba(255,255,255,0.1); margin: 20px 0; }
        .roulette-inner { display: flex; position: absolute; left: 0; top: 20px; transition: transform 6.5s cubic-bezier(0.1, 0, 0.1, 1); will-change: transform; }
        .roulette-item { width: 120px; height: 120px; flex-shrink: 0; margin: 0 8px; display: flex; flex-direction: column; align-items: center; justify-content: center; background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05)); border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); }
        .roulette-item .emoji { font-size: 3.5rem; }
        .roulette-item .name { font-size: 11px; opacity: 0.8; text-align: center; margin-top: 4px; }
        .roulette-pointer { position: absolute; left: 50%; top: 0; bottom: 0; width: 4px; background: #ff4757; z-index: 20; transform: translateX(-50%); box-shadow: 0 0 20px #ff4757; }
        .roulette-pointer::before { content: ''; position: absolute; top: -5px; left: 50%; transform: translateX(-50%); border-left: 10px solid transparent; border-right: 10px solid transparent; border-top: 15px solid #ff4757; }
        .roulette-pointer::after { content: ''; position: absolute; bottom: -5px; left: 50%; transform: translateX(-50%); border-left: 10px solid transparent; border-right: 10px solid transparent; border-bottom: 15px solid #ff4757; }
        
        .glass { background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); }
        .line-through { text-decoration: line-through; opacity: 0.6; color: #ef4444; text-decoration-thickness: 2px; }
        .fullscreen-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 100; overflow-y: auto; }
        
        /* ICE ARENA CSS */
        .ice-circle { width: 300px; height: 300px; border-radius: 50%; border: 4px solid rgba(0,210,255,0.6); position: relative; overflow: hidden; background: rgba(0, 40, 80, 0.6); box-shadow: 0 0 40px rgba(0,210,255,0.4), inset 0 0 60px rgba(0,0,0,0.5); }
        .ice-ball { position: absolute; width: 32px; height: 32px; background: radial-gradient(circle at 30% 30%, #ffffff, #00d2ff, #0066ff); border-radius: 50%; box-shadow: 0 0 15px rgba(0,210,255,0.9), 0 0 30px rgba(0,150,255,0.5); z-index: 20; transform: translate(-50%, -50%); border: 2px solid rgba(255,255,255,0.8); transition: left 0.025s linear, top 0.025s linear; }
        .player-avatar { position: absolute; width: 36px; height: 36px; border-radius: 50%; border: 3px solid white; overflow: hidden; transform: translate(-50%, -50%); z-index: 10; box-shadow: 0 0 10px rgba(0,0,0,0.5); }
        .player-row-ready { border-color: rgba(0,255,100,0.5) !important; background: rgba(0,255,100,0.1) !important; }
        .player-row-waiting { border-color: rgba(255,200,0,0.4) !important; background: rgba(255,200,0,0.05) !important; }
        .player-row-presence { border-color: rgba(150,150,150,0.3) !important; }

        .case-cardboard { background: linear-gradient(135deg, #8B4513 0%, #D2691E 50%, #8B4513 100%); border: 3px solid #A0522D; }
        .case-collector { background: linear-gradient(135deg, #DC143C 0%, #FF1493 50%, #8B008B 100%); border: 3px solid #FFD700; }
        
        /* TIMERS & GLOWS */
        @keyframes goldGlow { 0%, 100% { text-shadow: 0 0 5px #facc15, 0 0 10px #facc15; } 50% { text-shadow: 0 0 20px #facc15, 0 0 30px #eab308; } }
        @keyframes purpleGlow { 0%, 100% { text-shadow: 0 0 5px #a855f7, 0 0 10px #a855f7; } 50% { text-shadow: 0 0 20px #a855f7, 0 0 30px #9333ea; } }
        @keyframes greenGlow { 0%, 100% { box-shadow: 0 0 5px #22c55e, 0 0 10px #22c55e; } 50% { box-shadow: 0 0 15px #22c55e, 0 0 25px #16a34a; } }
        @keyframes yellowGlow { 0%, 100% { text-shadow: 0 0 5px #fbbf24, 0 0 10px #fbbf24; } 50% { text-shadow: 0 0 20px #fbbf24, 0 0 30px #f59e0b; } }
        
        .special-header { animation: purpleGlow 3s infinite; }
        .ordinary-header { animation: goldGlow 3s infinite; }
        
        .daily-timer { 
            color: #4ade80; 
            font-family: monospace; 
            font-weight: bold; 
            font-size: 14px;
            background: rgba(0,0,0,0.6);
            padding: 2px 8px;
            border-radius: 6px;
            border: 1px solid #22c55e;
            animation: greenGlow 2s infinite;
            display: inline-block;
        }
        .event-timer { color: #ffffff; font-family: monospace; text-shadow: 0 0 10px #ffffff, 0 0 20px #ffffff; }
        .case-countdown-overlay { position: absolute; top: 0; left: 0; right: 0; background: rgba(0,0,0,0.7); padding: 4px; font-size: 10px; color: #fbbf24; text-align: center; font-family: monospace; z-index: 10; text-shadow: 0 0 5px #fbbf24; }
        .olympus-font { font-family: 'Georgia', serif; font-weight: bold; }
        .events-tab-active { background: linear-gradient(135deg, rgba(251,191,36,0.3), rgba(245,158,11,0.2)); border: 2px solid rgba(251,191,36,0.6); box-shadow: 0 0 20px rgba(251,191,36,0.4); }
    </style>
</head>
<body class="bg-gradient-to-br from-indigo-600 via-purple-600 to-pink-600 min-h-screen text-white overflow-x-hidden">
    <div id="root"></div>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        
        const firebaseConfig = {
            apiKey: "AIzaSyDZPRiByz69HQa8b7GFMCJeqq56J3Y-bOY",
            authDomain: "step-by-step-279df.firebaseapp.com",
            databaseURL: "https://step-by-step-279df-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "step-by-step-279df",
            storageBucket: "step-by-step-279df.firebasestorage.app",
            messagingSenderId: "302641152597",
            appId: "1:302641152597:web:6479b9ae03104666cd8adc"
        };
        if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
        const db = firebase.database();
        const TelegramWebApp = window.Telegram?.WebApp;
        const ADMIN_WALLET = 'UQAWqaIPFSg81l9MlgAx0HBE9o3gpJMhk1dnyryKJXhWNHIc';
        const BOT_TOKEN = '8325421899:AAG9t3yS4WWiwasRoHb-nbr3a94S9tQfHys';
        
        const PLAYER_COLORS = ['#FF6B6B','#FF9F43','#FFEAA7','#55EFC4','#74B9FF','#A29BFE','#FD79A8','#E17055','#00CEC9','#6C5CE7','#FDCB6E','#81ECEC','#FF7675','#DFE6E9','#B2BEC3'];
        function getRandomColor() { return PLAYER_COLORS[Math.floor(Math.random() * PLAYER_COLORS.length)]; }
        
        const INITIAL_CASES = {
            daily: { id: 'daily', name: 'Ð•Ð¶ÐµÐ´Ð½ÐµÐ²Ð½Ñ‹Ð¹', emoji: 'ðŸ—“ï¸', price: 0, color: 'from-cyan-400 to-teal-600', locked: false, isNew: true, freeCount: 1, type: 'special', lastOpened: 0 },
            winter: { id: 'winter', name: 'Ð—Ð¸Ð¼Ð½Ð¸Ð¹', emoji: 'â˜ƒï¸', price: 125, color: 'from-cyan-400 to-blue-500', locked: false, isNew: true, freeCount: 0, type: 'special' },
            man: { id: 'man', name: 'ÐœÑƒÐ¶Ñ‹Ðº', emoji: 'ðŸ’ª', price: 100, color: 'from-slate-700 to-slate-900', locked: false, isNew: true, freeCount: 0, type: 'special' },
            collector: { id: 'collector', name: 'ÐšÐ¾Ð»Ð»ÐµÐºÑ†Ð¸Ð¾Ð½ÐµÑ€', emoji: 'ðŸŽ©', price: 650, color: 'from-rose-600 to-pink-800', locked: true, isNew: true, freeCount: 0, type: 'special' },
            cardboard: { id: 'cardboard', name: 'ÐšÐ°Ñ€Ñ‚Ð¾Ð½', emoji: 'ðŸ“¦', price: 3, color: 'from-amber-800 to-amber-900', locked: false, isNew: true, freeCount: 0 },
            coal: { id: 'coal', name: 'Ð£Ð³Ð¾Ð»Ñ‘Ðº', emoji: 'ðŸª¨', price: 27, color: 'from-gray-600 to-gray-800', locked: false, isNew: false, freeCount: 0 },
            platinum: { id: 'platinum', name: 'ÐŸÐ»Ð°Ñ‚Ð¸Ð½Ð°', emoji: 'ðŸ’Ž', price: 100, color: 'from-gray-300 to-gray-500', locked: false },
            gold: { id: 'gold', name: 'Ð—Ð¾Ð»Ð¾Ñ‚Ð¾Ð¹', emoji: 'ðŸ‘‘', price: 250, color: 'from-yellow-400 to-yellow-600', locked: false },
            money: { id: 'money', name: 'Ð”ÐµÐ½ÐµÐ¶Ð½Ñ‹Ð¹', emoji: 'ðŸ’µ', price: 350, color: 'from-green-400 to-green-600', locked: false },
            elite: { id: 'elite', name: 'Ð­Ð»Ð¸Ñ‚Ð°', emoji: 'ðŸŽ–', price: 500, color: 'from-red-400 to-red-600', locked: false, isNew: false, freeCount: 0 },
            diamond: { id: 'diamond', name: 'ÐÐ»Ð¼Ð°Ð·', emoji: 'ðŸ’Ž', price: 50, color: 'from-blue-400 to-blue-600', locked: false, isNew: false, freeCount: 0 },
            major: { id: 'major', name: 'ÐœÐ°Ð¶Ð¾Ñ€', emoji: 'ðŸ¤´', price: 800, color: 'from-purple-500 to-indigo-700', locked: true, isNew: false, freeCount: 0 },
            star: { id: 'star', name: 'Ð—Ð²ÐµÐ·Ð´Ð½Ñ‹Ð¹', emoji: 'â­ï¸', price: 30, originalPrice: 30, discountPrice: 23, color: 'from-yellow-400 to-amber-500', locked: false, isNew: true, freeCount: 0 }
        };
        
        const CASE_REWARDS = {
            daily: [
                { id: 'stars_1', name: '1 â­ï¸', emoji: 'â­ï¸', type: 'stars', value: 1, realChance: 50, displayChance: '50%' },
                { id: 'stars_3', name: '3 â­ï¸', emoji: 'â­ï¸', type: 'stars', value: 3, realChance: 35, displayChance: '35%' },
                { id: 'stars_15', name: '15 â­ï¸', emoji: 'â­ï¸', type: 'stars', value: 15, realChance: 10, displayChance: '10%' },
                { id: 'pickaxe', name: 'ÐšÐ¸Ñ€ÐºÐ° â›ï¸', emoji: 'â›ï¸', type: 'item', sellPrice: 22, realChance: 4, displayChance: '4%' },
                { id: 'random_case_box', name: 'Ð¡Ð»ÑƒÑ‡Ð°Ð¹Ð½Ñ‹Ð¹ ÐºÐµÐ¹Ñ', emoji: 'ðŸ“¦', type: 'random_case_box', realChance: 1, displayChance: '1%' },
            ],
            cardboard: [
                { id: 'stars_0_25', name: '0.25 â­ï¸', displayChance: '80%', realChance: 80, type: 'stars', value: 0.25, emoji: 'â­ï¸' },
                { id: 'stars_0_75', name: '0.75 â­ï¸', displayChance: '10%', realChance: 10, type: 'stars', value: 0.75, emoji: 'â­ï¸' },
                { id: 'stars_1_5', name: '1.5 â­ï¸', displayChance: '6%', realChance: 6, type: 'stars', value: 1.5, emoji: 'â­ï¸' },
                { id: 'stars_5', name: '5 â­ï¸', displayChance: '2%', realChance: 2, type: 'stars', value: 5, emoji: 'â­ï¸' },
                { id: 'bear', name: 'ðŸ§¸', displayChance: '1.5%', realChance: 1.5, type: 'item', sellPrice: 20, emoji: 'ðŸ§¸' },
                { id: 'diamond_pro', name: 'ðŸ’Ž PRO', displayChance: '0.5%', realChance: 0.5, type: 'collectible', emoji: 'ðŸ’Ž' }
            ],
            coal: [
                { id: 'stars_5', name: '5 â­ï¸', displayChance: '60.5%', realChance: 60.5, type: 'stars', value: 5, emoji: 'â­ï¸' },
                { id: 'stars_12', name: '12 â­ï¸', displayChance: '18%', realChance: 18, type: 'stars', value: 12, emoji: 'â­ï¸' },
                { id: 'pickaxe', name: 'ÐšÐ¸Ñ€ÐºÐ° â›ï¸', displayChance: '10%', realChance: 10, type: 'item', sellPrice: 22, emoji: 'â›ï¸' },
                { id: 'stars_30', name: '30 â­ï¸', displayChance: '6%', realChance: 6, type: 'stars', value: 30, emoji: 'â­ï¸' },
                { id: 'material', name: 'ÐœÐ°Ñ‚ÐµÑ€Ð¸Ð°Ð» ðŸ§±', displayChance: '5%', realChance: 5, type: 'item', sellPrice: 80, emoji: 'ðŸ§±' },
                { id: 'brownie_pro', name: 'Happy Brownie PRO ðŸ’©', displayChance: '0.5%', realChance: 0.001, type: 'collectible', emoji: 'ðŸ’©' }
            ],
            platinum: [
                { id: 'stars_35', name: '35 â­ï¸', displayChance: '55%', realChance: 55, type: 'stars', value: 35, emoji: 'â­ï¸' },
                { id: 'stars_50', name: '50 â­ï¸', displayChance: '35%', realChance: 35, type: 'stars', value: 50, emoji: 'â­ï¸' },
                { id: 'ring', name: 'ðŸ’', displayChance: '5%', realChance: 5, type: 'collectible', emoji: 'ðŸ’' },
                { id: 'bday', name: 'B-day ðŸ—“', displayChance: '4%', realChance: 4, type: 'item', sellPrice: 150, emoji: 'ðŸ—“' },
                { id: 'bday_pro', name: 'B-Day PRO ðŸ“…', displayChance: '1%', realChance: 1, type: 'collectible', emoji: 'ðŸ“…' }
            ],
            gold: [
                { id: 'stars_50', name: '50 â­ï¸', displayChance: '50%', realChance: 50, type: 'stars', value: 50, emoji: 'â­ï¸' },
                { id: 'stars_125', name: '125 â­ï¸', displayChance: '35%', realChance: 35, type: 'stars', value: 125, emoji: 'â­ï¸' },
                { id: 'clover', name: 'ðŸ€ Clover Pin', displayChance: '10%', realChance: 10, type: 'item', sellPrice: 200, emoji: 'ðŸ€' },
                { id: 'icecream', name: 'Ice Cream ðŸ¦', displayChance: '3%', realChance: 3, type: 'collectible', emoji: 'ðŸ¦' },
                { id: 'clover_pro', name: 'ðŸ€ Clover Pin PRO', displayChance: '2%', realChance: 2, type: 'collectible', emoji: 'ðŸ€' }
            ],
            money: [
                { id: 'stars_150', name: '150 â­ï¸', displayChance: '45%', realChance: 45, type: 'stars', value: 150, emoji: 'â­ï¸' },
                { id: 'stars_75', name: '75 â­ï¸', displayChance: '40%', realChance: 40, type: 'stars', value: 75, emoji: 'â­ï¸' },
                { id: 'trophy', name: 'ðŸ†', displayChance: '5%', realChance: 5, type: 'collectible', emoji: 'ðŸ†' },
                { id: 'gem', name: 'ðŸ’Ž', displayChance: 5, realChance: 5, type: 'collectible', emoji: 'ðŸ’Ž' },
                { id: 'bday_happy', name: 'Happy B-day ðŸ’ˆ', displayChance: '4%', realChance: 4, type: 'collectible', emoji: 'ðŸ’ˆ' },
                { id: 'cigar', name: 'Snoop Cigar ðŸš¬', displayChance: '1%', realChance: 1, type: 'collectible', emoji: 'ðŸš¬' }
            ],
            elite: [
                { id: 'stars_200', name: '200 â­ï¸', displayChance: '65%', realChance: 65, type: 'stars', value: 200, emoji: 'â­ï¸' },
                { id: 'stars_275', name: '275 â­ï¸', displayChance: '25%', realChance: 25, type: 'stars', value: 275, emoji: 'â­ï¸' },
                { id: 'champagne', name: 'ðŸ¾', displayChance: '8.5%', realChance: 8.5, type: 'collectible', emoji: 'ðŸ¾' },
                { id: 'socks', name: 'ÐÐ¾ÑÐºÐ¸ ðŸ§¦', displayChance: '1%', realChance: 1, type: 'collectible', emoji: 'ðŸ§¦' },
                { id: 'lightsword', name: 'Light Sword âš”ï¸', displayChance: '0.5%', realChance: 0.5, type: 'collectible', emoji: 'âš”ï¸' }
            ],
            diamond: [
                { id: 'stars_8', name: '8 â­ï¸', displayChance: '70%', realChance: 70, type: 'stars', value: 8, emoji: 'â­ï¸' },
                { id: 'bear', name: 'ÐœÐ¸ÑˆÐºÐ° ðŸ§¸', displayChance: '15%', realChance: 15, type: 'item', sellPrice: 20, emoji: 'ðŸ§¸' },
                { id: 'stars_25', name: '25 â­ï¸', displayChance: '9%', realChance: 9, type: 'stars', value: 25, emoji: 'â­ï¸' },
                { id: 'stars_80', name: '80 â­ï¸', displayChance: '4%', realChance: 4, type: 'stars', value: 80, emoji: 'â­ï¸' },
                { id: 'diamond_pro', name: 'ÐÐ»Ð¼Ð°Ð· PRO ðŸ’Ž', displayChance: '0.6%', realChance: 0.6, type: 'collectible', emoji: 'ðŸ’Ž' },
                { id: 'snoop_pro', name: 'Snoop Dog PRO ðŸ•', displayChance: '0.4%', realChance: 0.4, type: 'collectible', emoji: 'ðŸ•' }
            ],
            winter: [
                { id: 'stars_20', name: '20 â­ï¸', displayChance: '60%', realChance: 60, type: 'stars', value: 20, emoji: 'â­ï¸' },
                { id: 'stars_35', name: '35 â­ï¸', displayChance: '35%', realChance: 35, type: 'stars', value: 35, emoji: 'â­ï¸' },
                { id: 'stars_80', name: '80 â­ï¸', displayChance: '3.5%', realChance: 3.5, type: 'stars', value: 80, emoji: 'â­ï¸' },
                { id: 'snake', name: 'ðŸŽ„ Lunar Snake 2025 ðŸ', displayChance: '1%', realChance: 1, type: 'collectible', emoji: 'ðŸ' },
                { id: 'scarf', name: 'ðŸ§£ Ð—Ð¸Ð¼Ð½ÐµÐµ ÑÐ¾ÐºÑ€Ð¾Ð²Ð¸Ñ‰Ðµ', displayChance: '0.5%', realChance: 0.5, type: 'collectible', emoji: 'ðŸ§£' }
            ],
            major: [
                { id: 'stars_500', name: '500 â­ï¸', displayChance: '50%', realChance: 50, type: 'stars', value: 500, emoji: 'â­ï¸' },
                { id: 'stars_1000', name: '1000 â­ï¸', displayChance: '25%', realChance: 25, type: 'stars', value: 1000, emoji: 'â­ï¸' },
                { id: 'stars_2500', name: '2500 â­ï¸', displayChance: '10%', realChance: 10, type: 'stars', value: 2500, emoji: 'â­ï¸' },
                { id: 'stars_5000', name: '5000 â­ï¸', displayChance: '5%', realChance: 5, type: 'stars', value: 5000, emoji: 'â­ï¸' },
                { id: 'car', name: 'ðŸš— ÐÐ²Ñ‚Ð¾Ð¼Ð¾Ð±Ð¸Ð»ÑŒ', displayChance: '5%', realChance: 5, type: 'collectible', emoji: 'ðŸš—' },
                { id: 'diamond_ring', name: 'ðŸ’ Ð‘Ñ€Ð¸Ð»Ð»Ð¸Ð°Ð½Ñ‚Ð¾Ð²Ð¾Ðµ ÐºÐ¾Ð»ÑŒÑ†Ð¾', displayChance: '3%', realChance: 3, type: 'collectible', emoji: 'ðŸ’' },
                { id: 'gold_bar', name: 'ðŸ¥‡ Ð—Ð¾Ð»Ð¾Ñ‚Ð¾Ð¹ ÑÐ»Ð¸Ñ‚Ð¾Ðº', displayChance: '2%', realChance: 2, type: 'collectible', emoji: 'ðŸ¥‡' }
            ],
            collector: [
                { id: 'bear_pro', name: 'ðŸ§¸ PRO', displayChance: '55%', realChance: 55, type: 'collectible', emoji: 'ðŸ§¸' },
                { id: 'gift_pro', name: 'ðŸŽ PRO', displayChance: '20%', realChance: 20, type: 'collectible', emoji: 'ðŸŽ' },
                { id: 'rocket_pro', name: 'ðŸš€ PRO', displayChance: '15%', realChance: 15, type: 'collectible', emoji: 'ðŸš€' },
                { id: 'cup_pro', name: 'ðŸ† PRO', displayChance: '5%', realChance: 5, type: 'collectible', emoji: 'ðŸ†' },
                { id: 'cake_candle', name: 'ðŸ° B-day Candle', displayChance: '2%', realChance: 2, type: 'collectible', emoji: 'ðŸ°' },
                { id: 'ramen_pro', name: 'ðŸœ Ramen PRO', displayChance: '1.5%', realChance: 0.5, type: 'collectible', emoji: 'ðŸœ' },
                { id: 'hat_pro', name: 'ðŸŽ© Top hat', displayChance: '1%', realChance: 0, type: 'collectible', emoji: 'ðŸŽ©' },
                { id: 'bird_pro', name: 'ðŸ¦… Rare bird', displayChance: '0.5%', realChance: 0, type: 'collectible', emoji: 'ðŸ¦…' }
            ],
            man: [
                { id: 'ball_gold', name: 'Ð—Ð¾Ð»Ð¾Ñ‚Ð¾Ð¹ Ð¼ÑÑ‡ âš½ï¸', displayChance: '30%', realChance: 30, type: 'man_item', key: 'gold_ball', emoji: 'âš½ï¸', sellPrice: 5 },
                { id: 'ball_volley', name: 'ÐœÑÑ‡ ÐœÐ°ÐºÑÐ¸Ð¼Ð° ÐœÐ¸Ñ…Ð°Ð¹Ð»Ð¾Ð²Ð° ðŸ', displayChance: '30%', realChance: 30, type: 'man_item', key: 'mikhaylov_ball', emoji: 'ðŸ', sellPrice: 7 },
                { id: 'gloves_tyson', name: 'ÐŸÐµÑ€Ñ‡Ð°Ñ‚ÐºÐ¸ ÐœÐ°Ð¹ÐºÐ° Ð¢Ð°Ð¹ÑÐ¾Ð½Ð° ðŸ¥Š', displayChance: '20%', realChance: 20, type: 'man_item', key: 'tyson_gloves', emoji: 'ðŸ¥Š', sellPrice: 15 },
                { id: 'steak', name: 'Ð¡Ñ‚ÐµÐ¹Ðº ðŸ¥©', displayChance: '10%', realChance: 10, type: 'man_item', key: 'steak', emoji: 'ðŸ¥©', sellPrice: 20 },
                { id: 'elite_spin', name: '1 Ð±ÐµÑÐ¿Ð»Ð°Ñ‚Ð½Ñ‹Ð¹ ÐºÐµÐ¹Ñ Â«Ð­Ð»Ð¸Ñ‚Ð°ðŸŽ–ï¸Â»', displayChance: '5%', realChance: 5, type: 'man_bonus_elite', emoji: 'ðŸŽ–ï¸' },
                { id: 'simba', name: 'Ð¡Ð¸Ð¼Ð±Ð° ðŸ¦', displayChance: '4%', realChance: 4, type: 'man_item', key: 'simba', emoji: 'ðŸ¦', sellPrice: 50 },
                { id: 'wolf_wallstreet', name: 'Ð’Ð¾Ð»Ðº Ñ Ð£Ð¾Ð»Ð»-ÑÑ‚Ñ€Ð¸Ñ‚ ðŸº', displayChance: '1%', realChance: 1, type: 'man_item', key: 'wolf_wallstreet', emoji: 'ðŸº', sellPrice: 0 }
            ],
            star: Array.from({length: 100}, (_, i) => ({
                id: `stars_${i+1}`, name: `${i+1} â­ï¸`, emoji: 'â­ï¸', type: 'stars', value: i+1, realChance: 1, displayChance: '1%'
            }))
        };
        
        const ICE_ARENA_PRIZES = [
            { id: 'bear', name: 'ðŸ§¸ ÐœÐ¸ÑˆÐºÐ°', chance: 40, type: 'item', sellPrice: 20, emoji: 'ðŸ§¸' },
            { id: 'gloves', name: 'ðŸ§¤ Ð’Ð°Ñ€ÐµÐ¶ÐºÐ¸', chance: 30, type: 'item', sellPrice: 50, emoji: 'ðŸ§¤' },
            { id: 'fire', name: 'ðŸ”¥ ÐžÐ³Ð¾Ð½ÑŒ', chance: 10, type: 'special', emoji: 'ðŸ”¥', message: 'Ð’Ñ‹ Ñ€Ð°ÑÑ‚Ð¾Ð¿Ð¸Ð»Ð¸ Ð»Ñ‘Ð´! ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÑ‚Ðµ 40% Ð¾Ñ‚ ÑÑ‚Ð°Ð²Ð¾Ðº' },
            { id: 'snow', name: 'â„ï¸ Ð¡Ð½ÐµÐ¶Ð¸Ð½ÐºÐ°', chance: 5, type: 'item', sellPrice: 125, emoji: 'â„ï¸' },
            { id: 'snoop', name: 'ðŸ• Snoop Dog', chance: 5, type: 'item', sellPrice: 130, emoji: 'ðŸ•' },
            { id: 'winter_case', name: 'â˜ƒï¸ ÐšÐµÐ¹Ñ Ð—Ð¸Ð¼Ð½Ð¸Ð¹', chance: 4, type: 'case_free', caseType: 'winter', emoji: 'â˜ƒï¸' },
            { id: 'elite_case', name: 'ðŸŽ– ÐšÐµÐ¹Ñ Ð­Ð»Ð¸Ñ‚Ð½Ñ‹Ð¹', chance: 3, type: 'case_free', caseType: 'elite', emoji: 'ðŸŽ–' },
            { id: 'stars_350', name: '350 â­ï¸', chance: 2, type: 'stars', value: 350, emoji: 'â­ï¸' },
            { id: 'scarf', name: 'ðŸ§£ Ð—Ð¸Ð¼Ð½ÐµÐµ ÑÐ¾ÐºÑ€Ð¾Ð²Ð¸Ñ‰Ðµ', chance: 0.5, type: 'collectible', emoji: 'ðŸ§£' },
            { id: 'dellko', name: 'ðŸ”‘ Promocode DELLKO', chance: 0.5, type: 'promo', code: 'DELLKO', emoji: 'ðŸ”‘' }
        ];
        
        const TON_RATES = [{ stars: 50, ton: 0.6 }, { stars: 250, ton: 3 }, { stars: 500, ton: 6 }, { stars: 1000, ton: 12 }];
        const STARS_PACKAGES = [ { stars: 50, price: 50 }, { stars: 100, price: 100 }, { stars: 250, price: 250 }, { stars: 500, price: 500 }, { stars: 1000, price: 1000 } ];
        const DEFAULT_LOBBY = { status: 'waiting', players: {}, presence: {}, readyPlayers: {}, winner: null, prizes: [], wonStars: 0, ballPosition: { x: 50, y: 50, vx: 0, vy: 0 }, countdownEnd: null, prizeClaimed: {}, finalBall: null, gameStartedAt: null };
        
        function App() {
            const [currentScreen, setCurrentScreen] = useState('cases');
            const [balance, setBalance] = useState(0);
            const [cases, setCases] = useState(INITIAL_CASES);
            const [inventory, setInventory] = useState([]);
            const [inventorySlots, setInventorySlots] = useState(5);
            const [tasks, setTasks] = useState({ subscribe: { completed: false }, deposit: { completed: false }, depositMajor: { completed: false }, inviteThree: { completed: false, count: 0, required: 3, reward: 25 } });
            const [user, setUser] = useState(null);
            const [isLoading, setIsLoading] = useState(true);
            const [dailyCaseTimeLeft, setDailyCaseTimeLeft] = useState('');
            const [eventOlympusTimeLeft, setEventOlympusTimeLeft] = useState('');
            const [eventCasesTimeLeft, setEventCasesTimeLeft] = useState('');
            const [selectedCase, setSelectedCase] = useState(null);
            const [isSpinning, setIsSpinning] = useState(false);
            const [spinResult, setSpinResult] = useState(null);
            const [rouletteOffset, setRouletteOffset] = useState(0);
            const [fakeItems, setFakeItems] = useState([]);
            const [rouletteKey, setRouletteKey] = useState(0);
            const rouletteContainerRef = useRef(null);
            const [showTopUp, setShowTopUp] = useState(false);
            const [promoCode, setPromoCode] = useState('');
            const [promoError, setPromoError] = useState('');
            const [promoSuccess, setPromoSuccess] = useState('');
            const [usedPromos, setUsedPromos] = useState([]);
            const [wonPromos, setWonPromos] = useState([]);
            const [showCollectibleModal, setShowCollectibleModal] = useState(false);
            const [selectedCollectible, setSelectedCollectible] = useState(null);
            const [showIceGiftModal, setShowIceGiftModal] = useState(false);
            const [selectedIceGift, setSelectedIceGift] = useState(null);
            const [showManItemModal, setShowManItemModal] = useState(false);
            const [selectedManItem, setSelectedManItem] = useState(null);
            const [showRandomCaseModal, setShowRandomCaseModal] = useState(false);
            const [randomCaseItem, setRandomCaseItem] = useState(null);
            const [showWithdrawModal, setShowWithdrawModal] = useState(false);
            const [withdrawAmount, setWithdrawAmount] = useState('');
            const [showAdminLogin, setShowAdminLogin] = useState(false);
            const [adminLogin, setAdminLogin] = useState('');
            const [adminPassword, setAdminPassword] = useState('');
            const [isAdmin, setIsAdmin] = useState(false);
            const [adminScreen, setAdminScreen] = useState('stats');
            const [allUsers, setAllUsers] = useState([]);
            const [selectedUser, setSelectedUser] = useState(null);
            const [adminUserSearch, setAdminUserSearch] = useState('');
            const [adminAttempts, setAdminAttempts] = useState(0);
            const [onlineCount, setOnlineCount] = useState(Math.floor(Math.random() * 300) + 200);
            const [paymentStatus, setPaymentStatus] = useState('');
            const [totalDeposits, setTotalDeposits] = useState(0);
            const [freeEliteSpin, setFreeEliteSpin] = useState(0);
            const [currentGame, setCurrentGame] = useState(null);
            const [iceLobby, setIceLobby] = useState(null);
            const [gameStatus, setGameStatus] = useState('waiting');
            const [ballPos, setBallPos] = useState({ x: 50, y: 50 });
            const [timerRemaining, setTimerRemaining] = useState(0);
            const [myBet, setMyBet] = useState(25);
            const [myBetInput, setMyBetInput] = useState(25);
            const [hasBet, setHasBet] = useState(false);
            const [isReady, setIsReady] = useState(false);
            const [myColor, setMyColor] = useState('');
            const [presenceCount, setPresenceCount] = useState(0);
            const [bettingCount, setBettingCount] = useState(0);
            const [readyCount, setReadyCount] = useState(0);
            const [showVictoryBox, setShowVictoryBox] = useState(false);
            const [victoryStars, setVictoryStars] = useState(0);
            const [victoryPrize, setVictoryPrize] = useState(null);
            const [boxOpened, setBoxOpened] = useState(false);
            const [prizeClaimedLocal, setPrizeClaimedLocal] = useState(false);
            
            useEffect(() => {
                const initApp = async () => {
                    let userId = null;
                    let userData = { name: 'Ð“Ð¾ÑÑ‚ÑŒ', username: null, avatar: null };
                    if (TelegramWebApp) {
                        TelegramWebApp.ready();
                        TelegramWebApp.expand();
                        const tgUser = TelegramWebApp.initDataUnsafe?.user;
                        if (tgUser) {
                            userId = tgUser.id.toString();
                            userData = { name: tgUser.first_name + (tgUser.last_name ? ' ' + tgUser.last_name : ''), username: tgUser.username ? '@' + tgUser.username : null, avatar: tgUser.photo_url || null };
                        }
                    }
                    if (!userId) {
                        userId = localStorage.getItem('sbs_user_id') || ('guest_' + Date.now());
                        localStorage.setItem('sbs_user_id', userId);
                    } else {
                        localStorage.setItem('sbs_user_id', userId);
                    }
                    try {
                        const snap = await db.ref('users/' + userId).once('value');
                        const data = snap.val();
                        if (data) {
                            const storedCases = data.cases || {};
                            const newMergedCases = {};
                            for (const caseId in INITIAL_CASES) {
                                const initialCase = INITIAL_CASES[caseId];
                                const storedCase = storedCases[caseId];
                                newMergedCases[caseId] = { ...initialCase };
                                if (storedCase) {
                                    newMergedCases[caseId].freeCount = storedCase.freeCount || 0;
                                    if (storedCase.locked !== undefined) newMergedCases[caseId].locked = storedCase.locked;
                                    if (caseId === 'daily' && storedCase.lastOpened) newMergedCases[caseId].lastOpened = storedCase.lastOpened;
                                }
                            }
                            setUser({ id: userId, ...userData, ...data });
                            setBalance(data.balance || 0);
                            setCases(newMergedCases);
                            setInventory(data.inventory || []);
                            setTasks(data.tasks || { subscribe: { completed: false }, deposit: { completed: false }, depositMajor: { completed: false }, inviteThree: { completed: false, count: 0, required: 3, reward: 25 } });
                            setInventorySlots(data.inventorySlots || 5);
                            setUsedPromos(data.usedPromos || []);
                            setWonPromos(data.wonPromos || []);
                            setTotalDeposits(data.totalDeposits || 0);
                            setFreeEliteSpin(data.freeEliteSpin || 0);
                            await db.ref('users/' + userId).update({ name: userData.name, username: userData.username || '', cases: newMergedCases });
                        } else {
                            const newCases = { ...INITIAL_CASES, daily: { ...INITIAL_CASES.daily, freeCount: 1, lastOpened: 0 }, diamond: { ...INITIAL_CASES.diamond, freeCount: 5 } };
                            const newUser = { balance: 0, cases: newCases, inventory: [], tasks: { subscribe: { completed: false }, deposit: { completed: false }, depositMajor: { completed: false }, inviteThree: { completed: false, count: 0, required: 3, reward: 25 } }, inventorySlots: 5, usedPromos: [], wonPromos: [], createdAt: Date.now(), lastActive: Date.now(), totalDeposits: 0, freeEliteSpin: 0, name: userData.name, username: userData.username || '' };
                            setCases(newCases);
                            setUser({ id: userId, ...userData });
                            await db.ref('users/' + userId).set(newUser);
                        }
                    } catch (e) { console.error(e); }
                    setIsLoading(false);
                };
                initApp();
            }, []);
            
            useEffect(() => {
                const olympusTarget = new Date('2026-03-01T15:00:00').getTime();
                const casesTarget = new Date('2026-03-01T12:00:00').getTime();
                const timer = setInterval(() => {
                    const now = Date.now();
                    const format = (diff) => {
                        if (diff <= 0) return '00:00:00';
                        const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                        const hours = Math.floor((diff / (1000 * 60 * 60)) % 24);
                        const mins = Math.floor((diff / (1000 * 60)) % 60);
                        const secs = Math.floor((diff / 1000) % 60);
                        return `${days}Ð´ ${String(hours).padStart(2,'0')}:${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}`;
                    };
                    setEventOlympusTimeLeft(format(olympusTarget - now));
                    setEventCasesTimeLeft(format(casesTarget - now));
                }, 1000);
                return () => clearInterval(timer);
            }, []);
            
            useEffect(() => {
                if (!user?.id) return;
                const ref = db.ref('online/' + user.id);
                ref.set({ name: user.name, timestamp: Date.now() });
                ref.onDisconnect().remove();
                db.ref('online').on('value', snap => setOnlineCount(Math.floor(Math.random() * 300) + 200 + snap.numChildren()));
                return () => ref.remove();
            }, [user?.id]);
            
            useEffect(() => {
                if (!user?.id || isLoading) return;
                const iv = setInterval(() => {
                    const dailyData = cases.daily;
                    db.ref('users/' + user.id).update({ 
                        balance, inventory, tasks, inventorySlots, usedPromos, wonPromos, lastActive: Date.now(), totalDeposits, freeEliteSpin,
                        'cases/daily/lastOpened': dailyData.lastOpened,
                        'cases/daily/freeCount': dailyData.freeCount
                    });
                }, 5000);
                return () => clearInterval(iv);
            }, [balance, cases, inventory, tasks, inventorySlots, usedPromos, wonPromos, user?.id, isLoading, totalDeposits, freeEliteSpin]);
            
            useEffect(() => {
                if (isLoading || !cases.daily) return;
                const DAILY_COOLDOWN = 23 * 60 * 60 * 1000;
                const timer = setInterval(() => {
                    const lastOpened = cases.daily.lastOpened || 0;
                    const now = Date.now();
                    const timePassed = now - lastOpened;
                    if (timePassed >= DAILY_COOLDOWN) {
                        if(cases.daily.freeCount === 0) {
                            setCases(prev => ({ ...prev, daily: { ...prev.daily, freeCount: 1 } }));
                        }
                        setDailyCaseTimeLeft('Ð”Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð¾!');
                    } else {
                        const remaining = DAILY_COOLDOWN - timePassed;
                        const h = Math.floor(remaining / (1000 * 60 * 60));
                        const m = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
                        const s = Math.floor((remaining % (1000 * 60)) / 1000);
                        setDailyCaseTimeLeft(`${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`);
                    }
                }, 1000);
                return () => clearInterval(timer);
            }, [cases.daily, isLoading]);
            
            useEffect(() => {
                if (!currentGame?.lobbyId || !user?.id) return;
                const lobbyRef = db.ref('iceLobbies/' + currentGame.lobbyId);
                lobbyRef.on('value', snap => {
                    const data = snap.val();
                    if (!data) return;
                    setIceLobby(data);
                    setGameStatus(data.status || 'waiting');
                    const players = data.players || {};
                    setPresenceCount(data.presence ? Object.keys(data.presence).length : 0);
                    setBettingCount(Object.keys(players).length);
                    setReadyCount(data.readyPlayers ? Object.keys(data.readyPlayers).length : 0);
                    if (players[user.id]) {
                        setHasBet(true);
                        setMyBet(players[user.id].bet);
                        setMyBetInput(players[user.id].bet);
                    } else if (data.status !== 'playing' && data.status !== 'countdown') {
                        setHasBet(false); setIsReady(false);
                    }
                    if (data.readyPlayers?.[user.id]) setIsReady(true);
                    else if (data.status === 'open') setIsReady(false);
                    if (data.ballPosition) setBallPos(data.ballPosition);
                    if (data.status === 'countdown' && data.countdownEnd) {
                        setTimerRemaining(Math.max(0, Math.ceil((data.countdownEnd - Date.now()) / 1000)));
                    }
                    if (data.status === 'finished' && data.winner?.id === user.id && !data.prizeClaimed?.[user.id] && !prizeClaimedLocal) {
                        setVictoryStars(data.wonStars || 0);
                        setVictoryPrize(data.prizes?.[0] || null);
                        setShowVictoryBox(true);
                        setBoxOpened(false);
                    }
                });
                return () => lobbyRef.off();
            }, [currentGame?.lobbyId, user?.id]);
            
            useEffect(() => {
                if(gameStatus !== 'countdown') return;
                const iv = setInterval(() => setTimerRemaining(p => (p <= 1 ? 0 : p - 1)), 1000);
                return () => clearInterval(iv);
            }, [gameStatus]);
            
            const joinIceLobby = async (lid) => {
                if(!user?.id) return;
                const ref = db.ref('iceLobbies/' + lid);
                const snap = await ref.once('value');
                const d = snap.val() || {};
                const st = d.status || 'waiting';
                setMyColor(getRandomColor());
                if(st === 'playing' || st === 'countdown') {
                    setCurrentGame({ type: 'ice', lobbyId: lid, spectator: true });
                } else {
                    setShowVictoryBox(false); setBoxOpened(false); setPrizeClaimedLocal(false); setHasBet(false); setIsReady(false);
                    setCurrentGame({ type: 'ice', lobbyId: lid, spectator: false });
                    await db.ref(`iceLobbies/${lid}/presence/${user.id}`).set({ name: user.name, avatar: user.avatar, joinedAt: Date.now(), color: getRandomColor() });
                    const s2 = await ref.once('value');
                    if((s2.val()?.presence ? Object.keys(s2.val().presence).length : 0) >= 2 && st === 'waiting') await ref.update({ status: 'open' });
                }
            };
            
            const leaveIceLobby = async () => {
                if(!currentGame?.lobbyId) return;
                const lid = currentGame.lobbyId;
                await db.ref(`iceLobbies/${lid}/presence/${user.id}`).remove();
                if(hasBet) {
                     const snap = await db.ref(`iceLobbies/${lid}`).once('value');
                     if(snap.val()?.status === 'open' || snap.val()?.status === 'waiting') {
                         const bet = snap.val().players[user.id].bet;
                         setBalance(b => b + bet);
                         await db.ref(`users/${user.id}/balance`).set(balance + bet);
                         await db.ref(`iceLobbies/${lid}/players/${user.id}`).remove();
                         await db.ref(`iceLobbies/${lid}/readyPlayers/${user.id}`).remove();
                     }
                }
                setCurrentGame(null);
            };
            
            const placeBet = async () => {
                if(gameStatus !== 'open' || balance < myBetInput) return;
                setBalance(b => b - myBetInput);
                await db.ref(`users/${user.id}/balance`).set(balance - myBetInput);
                await db.ref(`iceLobbies/${currentGame.lobbyId}/players/${user.id}`).set({ name: user.name, avatar: user.avatar, bet: myBetInput, color: myColor, timestamp: Date.now() });
                setHasBet(true); setMyBet(myBetInput);
            };
            
            const changeBet = async () => {
                 if(gameStatus !== 'open') return;
                 const ref = db.ref(`iceLobbies/${currentGame.lobbyId}`);
                 const snap = await ref.once('value');
                 const oldBet = snap.val().players[user.id].bet;
                 if(balance + oldBet < myBetInput) return;
                 setBalance(b => b + oldBet - myBetInput);
                 await db.ref(`users/${user.id}/balance`).set(balance + oldBet - myBetInput);
                 await ref.child(`players/${user.id}`).update({ bet: myBetInput });
                 setMyBet(myBetInput);
            };
            
            const toggleReady = async () => {
                if(!hasBet) return;
                const ref = db.ref(`iceLobbies/${currentGame.lobbyId}/readyPlayers/${user.id}`);
                if(isReady) { await ref.remove(); setIsReady(false); }
                else { 
                    await ref.set({ name: user.name, readyAt: Date.now() }); 
                    setIsReady(true);
                    const s = await db.ref(`iceLobbies/${currentGame.lobbyId}`).once('value');
                    const p = s.val().players || {};
                    const r = s.val().readyPlayers || {};
                    if(Object.keys(p).length >= 2 && Object.keys(r).length >= Object.keys(p).length) {
                        await db.ref(`iceLobbies/${currentGame.lobbyId}`).update({ status: 'countdown', countdownEnd: Date.now() + 10000 });
                        setTimeout(() => triggerGameStart(currentGame.lobbyId), 10000);
                    }
                }
            };
            
            const triggerGameStart = async (lid) => {
                const ref = db.ref(`iceLobbies/${lid}`);
                const s = await ref.once('value');
                if(s.val().status === 'countdown') {
                    await ref.update({ status: 'playing', gameStartedAt: Date.now() });
                    runPhysics(ref);
                }
            };
            
            const runPhysics = (ref) => {
                let x = 50, y = 50, vx = (Math.random()-0.5)*15, vy = (Math.random()-0.5)*15;
                const iv = setInterval(async () => {
                     x += vx * 0.4; y += vy * 0.4;
                     vx *= 0.994; vy *= 0.994;
                     if(Math.sqrt((x-50)**2 + (y-50)**2) > 44) { vx *= -1; vy *= -1; }
                     await ref.child('ballPosition').set({ x, y, vx, vy });
                     if(Math.abs(vx) < 0.1 && Math.abs(vy) < 0.1) {
                         clearInterval(iv);
                         finishIceGame(ref, x, y);
                     }
                }, 25);
            };
            
            const finishIceGame = async (ref, x, y) => {
                const s = await ref.once('value');
                const players = Object.entries(s.val().players);
                const total = players.reduce((a,b)=>a+b[1].bet,0);
                
                // Determine winner by angle
                const dx = x - 50; const dy = y - 50;
                let angle = Math.atan2(dy, dx) * 180 / Math.PI;
                if(angle < 0) angle += 360;
                
                const sorted = players.sort((a, b) => a[1].timestamp - b[1].timestamp);
                let currentAngle = 0;
                let winner = null;
                
                for(let [pid, p] of sorted) {
                    const sector = (p.bet / total) * 360;
                    // Check if angle is within this sector
                    if(angle >= currentAngle && angle < currentAngle + sector) {
                        winner = { id: pid, ...p };
                        break;
                    }
                    currentAngle += sector;
                }
                if(!winner) winner = { id: sorted[0][0], ...sorted[0][1] }; // Fallback

                await ref.update({ status: 'finished', winner, wonStars: Math.floor(total*0.65), prizes: [ICE_ARENA_PRIZES[0]], finalBall: {x,y} });
                if(winner.id === user.id) {
                    const nb = balance + Math.floor(total*0.65);
                    setBalance(nb);
                    await db.ref(`users/${user.id}/balance`).set(nb);
                }
            };
            
            const openVictoryBox = async () => {
                 setBoxOpened(true); setPrizeClaimedLocal(true);
                 await db.ref(`iceLobbies/${currentGame.lobbyId}/prizeClaimed/${user.id}`).set(true);
                 if(victoryPrize.type === 'stars') setBalance(b => b + victoryPrize.value);
                 else if(victoryPrize.type === 'item') addToInventory(victoryPrize);
            };
            
            const exitLobbyAfterGame = async () => {
                 await db.ref(`iceLobbies/${currentGame.lobbyId}`).set(DEFAULT_LOBBY);
                 setCurrentGame(null); setHasBet(false); setIsReady(false); setShowVictoryBox(false);
            };
            
            const exitLobbyNonWinner = async () => {
                 await db.ref(`iceLobbies/${currentGame.lobbyId}/presence/${user.id}`).remove();
                 setCurrentGame(null); setHasBet(false); setIsReady(false);
            };

            const renderIceField = () => {
                if(!iceLobby?.players) return null;
                const players = Object.entries(iceLobby.players);
                if (players.length === 0) return null;
                const totalBet = players.reduce((s, [, p]) => s + p.bet, 0);
                if (totalBet === 0) return null;
                const sorted = players.sort((a, b) => a[1].timestamp - b[1].timestamp);
                let currentAngle = 0;
                return sorted.map(([id, player]) => {
                    const pct = (player.bet / totalBet) * 100;
                    const sectorDeg = (player.bet / totalBet) * 360;
                    const midAngle = currentAngle + sectorDeg / 2;
                    const startAngle = currentAngle;
                    currentAngle += sectorDeg;
                    const avatarDist = 28;
                    const avatarX = 50 + avatarDist * Math.cos((midAngle - 90) * Math.PI / 180);
                    const avatarY = 50 + avatarDist * Math.sin((midAngle - 90) * Math.PI / 180);
                    const labelDist = 18;
                    const labelX = 50 + labelDist * Math.cos((midAngle - 90) * Math.PI / 180);
                    const labelY = 50 + labelDist * Math.sin((midAngle - 90) * Math.PI / 180);
                    return (
                        <React.Fragment key={id}>
                            <div className="absolute inset-0" style={{ background: `conic-gradient(from ${startAngle}deg at 50% 50%, ${player.color}bb ${sectorDeg}deg, transparent ${sectorDeg}deg)`, clipPath: 'circle(50% at 50% 50%)', borderRadius: '50%' }} />
                            <div className="absolute pointer-events-none font-bold text-white" style={{ left: `${labelX}%`, top: `${labelY}%`, transform: 'translate(-50%,-50%)', fontSize: '11px', textShadow: '0 0 6px black, 0 0 3px black' }}>{Math.round(pct)}%</div>
                            <div className="player-avatar" style={{ left: `${avatarX}%`, top: `${avatarY}%`, borderColor: player.color, boxShadow: `0 0 12px ${player.color}` }}>
                                {player.avatar ? <img src={player.avatar} className="w-full h-full object-cover" /> : <div className="w-full h-full flex items-center justify-center text-xs font-bold" style={{ background: player.color }}>{player.name[0]}</div>}
                            </div>
                        </React.Fragment>
                    );
                });
            };
            
            const getCasePrice = (ct) => {
                const c = cases[ct];
                if (!c) return 0;
                if (c.id === 'daily' && c.freeCount > 0) return 0;
                if (c.freeCount > 0) return 0;
                if (c.discountPrice && c.discountPrice !== c.price) return c.discountPrice;
                return c.price;
            };
            
            const handleSelectCase = (caseData) => {
                setSpinResult(null); setFakeItems([]); setSelectedCase(caseData);
            };
            
            const openCase = async (caseType) => {
                const cData = cases[caseType];
                if(cData.id === 'daily' && cData.freeCount === 0) { alert('Ð•Ð¶ÐµÐ´Ð½ÐµÐ²Ð½Ñ‹Ð¹ ÐºÐµÐ¹Ñ Ð½Ðµ Ð³Ð¾Ñ‚Ð¾Ð²!'); return; }
                const price = getCasePrice(caseType);
                const isFree = cData.freeCount > 0;
                if(!isFree && balance < price) { alert('ÐÐµÐ´Ð¾ÑÑ‚Ð°Ñ‚Ð¾Ñ‡Ð½Ð¾ Ð·Ð²ÐµÐ·Ð´!'); return; }
                let nb = balance;
                if(cData.id === 'daily' && isFree) {
                    const now = Date.now();
                    setCases(p => ({ ...p, daily: { ...p.daily, freeCount: 0, lastOpened: now } }));
                    await db.ref(`users/${user.id}/cases/daily`).update({ freeCount: 0, lastOpened: now });
                } else if(isFree) {
                     const nf = cData.freeCount - 1;
                     setCases(p => ({ ...p, [caseType]: { ...p[caseType], freeCount: nf } }));
                     await db.ref(`users/${user.id}/cases/${caseType}/freeCount`).set(nf);
                } else {
                     nb -= price;
                     setBalance(nb);
                     await db.ref(`users/${user.id}/balance`).set(nb);
                }
                setIsSpinning(false); setSpinResult(null); setFakeItems([]); setRouletteOffset(0); setRouletteKey(k => k+1);
                const items = CASE_REWARDS[caseType];
                let won = items[0], r = Math.random()*100, cum = 0;
                for(let i of items) { cum += i.realChance; if(r <= cum) { won = i; break; } }
                const tape = [];
                for(let i=0; i<80; i++) tape.push(i===70 ? won : items[Math.floor(Math.random()*items.length)]);
                setIsSpinning(true);
                setTimeout(() => {
                     setFakeItems(tape);
                     setTimeout(() => {
                         const cw = rouletteContainerRef.current ? rouletteContainerRef.current.offsetWidth : window.innerWidth;
                         const target = (70 * 136 + 68 - cw/2);
                         setRouletteOffset(-target);
                     }, 50);
                }, 50);
                setTimeout(async () => {
                     setSpinResult(won); setIsSpinning(false);
                     if(won.type === 'stars') {
                         const fb = nb + won.value;
                         setBalance(fb);
                         await db.ref(`users/${user.id}/balance`).set(fb);
                     } else {
                         await addToInventory(won);
                     }
                }, 6600);
            };
            
            const addToInventory = async (item) => {
                if(inventory.length >= inventorySlots) { alert('Ð˜Ð½Ð²ÐµÐ½Ñ‚Ð°Ñ€ÑŒ Ð¿Ð¾Ð»Ð¾Ð½!'); return; }
                const ni = [...inventory, { ...item, uniqueId: Date.now(), collected: Date.now() }];
                setInventory(ni);
                await db.ref(`users/${user.id}/inventory`).set(ni);
            };
            
            const sellItem = async (item) => {
                if(item.type === 'random_case_box') { setRandomCaseItem(item); setShowRandomCaseModal(true); return; }
                if(item.type === 'ice_gift') { setSelectedIceGift(item); setShowIceGiftModal(true); return; }
                if(item.type === 'man_item' || item.type === 'man_bonus_elite') { setSelectedManItem(item); setShowManItemModal(true); return; }
                if(item.type === 'collectible') { setSelectedCollectible(item); setShowCollectibleModal(true); return; }
                if(confirm(`ÐŸÑ€Ð¾Ð´Ð°Ñ‚ÑŒ ${item.name} Ð·Ð° ${item.sellPrice}â­ï¸?`)) {
                     const nb = balance + item.sellPrice;
                     const ni = inventory.filter(i => i.uniqueId !== item.uniqueId);
                     setBalance(nb); setInventory(ni);
                     await db.ref(`users/${user.id}`).update({ balance: nb, inventory: ni });
                }
            };
            
            const sellIceGift = async () => {
                 if(!selectedIceGift) return;
                 const nb = balance + 25;
                 const ni = inventory.filter(i => i.uniqueId !== selectedIceGift.uniqueId);
                 setBalance(nb); setInventory(ni);
                 await db.ref(`users/${user.id}`).update({ balance: nb, inventory: ni });
                 setShowIceGiftModal(false); setSelectedIceGift(null);
                 alert('ÐŸÑ€Ð¾Ð´Ð°Ð½Ð¾ Ð·Ð° 25â­ï¸!');
            };
            
            const exchangeRandomCaseBox = async () => {
                 const keys = ['cardboard','coal','platinum','diamond','money','gold','elite','collector'];
                 const rKey = keys[Math.floor(Math.random()*keys.length)];
                 const ni = inventory.filter(i => i.uniqueId !== randomCaseItem.uniqueId);
                 const nc = { ...cases, [rKey]: { ...cases[rKey], freeCount: (cases[rKey].freeCount||0)+1 } };
                 if(rKey === 'collector') nc.collector.locked = false;
                 setInventory(ni); setCases(nc);
                 await db.ref(`users/${user.id}`).update({ inventory: ni, cases: nc });
                 setShowRandomCaseModal(false); setRandomCaseItem(null);
                 alert(`Ð’Ñ‹Ð¿Ð°Ð» ÐºÐµÐ¹Ñ: ${cases[rKey].name}!`);
            };
            
            const unlockSlot = async () => {
                 if(balance < 50) return;
                 setBalance(b => b - 50); setInventorySlots(s => s + 1);
                 await db.ref(`users/${user.id}`).update({ balance: balance - 50, inventorySlots: inventorySlots + 1 });
            };
            
            const checkPromo = async () => {
                const code = promoCode.toUpperCase().trim();
                setPromoError(''); setPromoSuccess('');
                if(!code) return;
                if(usedPromos.includes(code)) { setPromoError('Ð£Ð¶Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½!'); return; }
                if(code === 'DELLKO') {
                     if(!wonPromos.includes('DELLKO')) { setPromoError('Ð¢Ð¾Ð»ÑŒÐºÐ¾ ÐµÑÐ»Ð¸ Ð²Ñ‹Ð¸Ð³Ñ€Ð°Ð»Ð¸ Ð² Ð›ÐµÐ´ÑÐ½Ð¾Ð¼ ÐšÐ°Ñ‚ÐºÐµ!'); return; }
                     const nc = { ...cases, money: { ...cases.money, freeCount: (cases.money.freeCount || 0) + 3 } };
                     setCases(nc);
                     await addToInventory({ name: 'ðŸ§Š Ð›Ñ‘Ð´ (1/3)', emoji: 'ðŸ§Š', type: 'ice', part: 1 });
                     setPromoSuccess('+3 Ð´ÐµÐ½ÐµÐ¶Ð½Ñ‹Ñ… ÐºÐµÐ¹ÑÐ° + ðŸ§Š!');
                     const np = [...usedPromos, code];
                     setUsedPromos(np);
                     setPromoCode('');
                     await db.ref(`users/${user.id}/usedPromos`).set(np);
                } else if(code === 'DIAMOND') {
                     const nc = { ...cases, diamond: { ...cases.diamond, freeCount: (cases.diamond.freeCount || 0) + 2 } };
                     setCases(nc);
                     setPromoSuccess('+2 ÐºÐµÐ¹ÑÐ° ÐÐ»Ð¼Ð°Ð·!');
                     const np = [...usedPromos, code];
                     setUsedPromos(np);
                     setPromoCode('');
                     await db.ref(`users/${user.id}/usedPromos`).set(np);
                } else if(code === 'DEFENDER') {
                     const nc = { ...cases, man: { ...cases.man, freeCount: (cases.man.freeCount || 0) + 5 } };
                     setCases(nc);
                     setPromoSuccess('+5 ÐºÐµÐ¹ÑÐ¾Ð² Â«ÐœÑƒÐ¶Ñ‹Ðº ðŸ’ªÂ»!');
                     const np = [...usedPromos, code];
                     setUsedPromos(np);
                     setPromoCode('');
                     await db.ref(`users/${user.id}/usedPromos`).set(np);
                } else if(code === 'PROMO') {
                     const nb = balance + 275;
                     setBalance(nb);
                     setPromoSuccess('âœ… ÐÐ°Ñ‡Ð¸ÑÐ»ÐµÐ½Ð¾ 275â­ï¸!');
                     const np = [...usedPromos, code];
                     setUsedPromos(np);
                     setPromoCode('');
                     await db.ref(`users/${user.id}`).update({ balance: nb, usedPromos: np });
                } else if(code === 'FEBRUARY') {
                     const nc = { ...cases, man: { ...cases.man, freeCount: (cases.man.freeCount || 0) + 4 } };
                     setCases(nc);
                     setPromoSuccess('+4 ÐºÐµÐ¹ÑÐ° Â«ÐœÑƒÐ¶Ñ‹Ðº ðŸ’ªÂ»!');
                     const np = [...usedPromos, code];
                     setUsedPromos(np);
                     setPromoCode('');
                     await db.ref(`users/${user.id}/usedPromos`).set(np);
                } else {
                     setPromoError('ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð¿Ñ€Ð¾Ð¼Ð¾ÐºÐ¾Ð´');
                }
            };
            
            const topUpBalance = async (stars, ton) => {
                 const pid = 'PAY_' + Date.now();
                 const memo = `SBS_${user.id}_${stars}_${pid}`;
                 const link = `ton://transfer/${ADMIN_WALLET}?amount=${Math.round(ton * 1e9)}&text=${encodeURIComponent(memo)}`;
                 window.open(link, '_blank');
                 setPaymentStatus(`ÐžÑ‚Ð¿Ñ€Ð°Ð²ÑŒÑ‚Ðµ ${ton} TON Ñ ÐºÐ¾Ð¼Ð¼ÐµÐ½Ñ‚Ð°Ñ€Ð¸ÐµÐ¼: ${memo}`);
                 setShowTopUp(false);
            };
            
            const buyStars = async (pkg) => {
                 try {
                     const r = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/createInvoiceLink`, {
                         method: 'POST',
                         headers: { 'Content-Type': 'application/json' },
                         body: JSON.stringify({ title: `${pkg.stars} Ð·Ð²Ñ‘Ð·Ð´`, description: `ÐŸÐ¾ÐºÑƒÐ¿ÐºÐ° ${pkg.stars} Ð·Ð²Ñ‘Ð·Ð´`, payload: `stars_${user.id}_${pkg.stars}_${Date.now()}`, currency: 'XTR', prices: [{ label: `${pkg.stars} Ð·Ð²Ñ‘Ð·Ð´`, amount: pkg.price }] })
                     });
                     const data = await r.json();
                     if(data.ok && data.result) {
                         if(TelegramWebApp) {
                             TelegramWebApp.openInvoice(data.result, async (status) => {
                                 if(status === 'paid') {
                                     const nb = balance + pkg.stars, nd = totalDeposits + pkg.stars;
                                     setBalance(nb); setTotalDeposits(nd);
                                     await db.ref(`users/${user.id}`).update({ balance: nb, totalDeposits: nd });
                                     checkDepositTasks(nd);
                                     alert(`âœ… Ð—Ð°Ñ‡Ð¸ÑÐ»ÐµÐ½Ð¾ ${pkg.stars} Ð·Ð²Ñ‘Ð·Ð´!`);
                                 }
                             });
                         } else {
                             window.open(data.result, '_blank');
                         }
                     }
                 } catch(e) { alert('ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ð»Ð°Ñ‚ÐµÐ¶Ð°.'); }
            };
            
            const checkDepositTasks = async (nd) => {
                 if(!tasks.deposit?.completed && nd >= 100) {
                     const nt = { ...tasks, deposit: { completed: true } };
                     const nc = { ...cases, gold: { ...cases.gold, freeCount: (cases.gold.freeCount || 0) + 1 } };
                     setTasks(nt); setCases(nc);
                     await db.ref(`users/${user.id}`).update({ tasks: nt, cases: nc });
                 }
                 if(!tasks.depositMajor?.completed && nd >= 350) {
                     const nt = { ...tasks, depositMajor: { completed: true } };
                     const nc = { ...cases, collector: { ...cases.collector, locked: false, freeCount: (cases.collector.freeCount || 0) + 1 } };
                     setTasks(nt); setCases(nc);
                     await db.ref(`users/${user.id}`).update({ tasks: nt, cases: nc });
                 }
            };
            
            const completeTask = async (tid) => {
                 if(tid === 'subscribe') {
                     window.open('https://t.me/stepbystepdelision', '_blank');
                     setTimeout(async () => {
                         if(!tasks.subscribe?.completed) {
                             const nt = { ...tasks, subscribe: { completed: true } };
                             const nc = { ...cases, elite: { ...cases.elite, freeCount: (cases.elite.freeCount || 0) + 1 } };
                             setTasks(nt); setCases(nc);
                             await db.ref(`users/${user.id}`).update({ tasks: nt, cases: nc });
                             alert('ðŸŽ‰ ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½ 1 ÐºÐµÐ¹Ñ Â«Ð­Ð»Ð¸Ñ‚Ð°Â»!');
                         }
                     }, 2000);
                 } else if(tid === 'inviteThree') {
                     window.open('https://t.me/share/url?url=' + encodeURIComponent(`https://t.me/stepbystep_game_bot?start=${user.id}`), '_blank');
                 } else if(tid === 'deposit' || tid === 'depositMajor') {
                     setShowTopUp(true);
                 }
            };
            
            const confirmWithdraw = () => {
                 alert('Ð”Ð»Ñ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ Ð½Ð°Ð³Ñ€Ð°Ð´Ñ‹ Ð¾Ð±Ñ€Ð°Ñ‚Ð¸Ñ‚ÐµÑÑŒ Ðº Ð°Ð´Ð¼Ð¸Ð½Ð¸ÑÑ‚Ñ€Ð°Ñ†Ð¸Ð¸! https://t.me/stepbystepdelision');
                 setShowWithdrawModal(false);
                 setWithdrawAmount('');
            };
            
            const handleTitleClick = () => { if(++adminAttempts >= 11) { setShowAdminLogin(true); setAdminAttempts(0); } };
            
            const checkAdminLogin = () => {
                 if(adminLogin === '_*\\^BAGUETTE_642819_6281' && adminPassword === '3628874910ZTWMI_') {
                     setIsAdmin(true);
                     setShowAdminLogin(false);
                     db.ref('users').once('value').then(snap => {
                         const u = [];
                         snap.forEach(c => u.push({ id: c.key, ...c.val() }));
                         setAllUsers(u);
                     });
                 } else {
                     alert('ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð»Ð¾Ð³Ð¸Ð½ Ð¸Ð»Ð¸ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ!');
                 }
            };
            
            const adminGiveReward = async (tid, r) => {
                 const snap = await db.ref('users/' + tid).once('value');
                 const ud = snap.val() || {};
                 if(r.type === 'stars') {
                     const nb = (ud.balance || 0) + r.amount;
                     await db.ref('users/' + tid + '/balance').set(nb);
                     if(tid === user.id) setBalance(nb);
                 } else if(r.type === 'case') {
                     const cur = ud.cases?.[r.caseType]?.freeCount || 0;
                     await db.ref(`users/${tid}/cases/${r.caseType}/freeCount`).set(cur + r.count);
                     if(tid === user.id) setCases(p => ({ ...p, [r.caseType]: { ...p[r.caseType], freeCount: cur + r.count } }));
                 } else if(r.type === 'unlock_collector') {
                     await db.ref(`users/${tid}/cases/collector/locked`).set(false);
                     if(tid === user.id) setCases(p => ({ ...p, collector: { ...p.collector, locked: false } }));
                 } else if(r.type === 'reset_daily') {
                     await db.ref(`users/${tid}/cases/daily`).update({ freeCount: 1, lastOpened: 0 });
                     if(tid === user.id) setCases(p => ({ ...p, daily: { ...p.daily, freeCount: 1, lastOpened: 0 } }));
                 } else if(r.type === 'item' && r.item) {
                     const currentInventory = ud.inventory || [];
                     const newItem = { ...r.item, uniqueId: Date.now(), collected: Date.now() };
                     const newInventory = [...currentInventory, newItem];
                     await db.ref(`users/${tid}/inventory`).set(newInventory);
                     if(tid === user.id) setInventory(newInventory);
                 }
                 alert('ÐÐ°Ð³Ñ€Ð°Ð´Ð° Ð²Ñ‹Ð´Ð°Ð½Ð°!');
            };
            
            // ===== ICE LOBBY SCREEN =====
            if(currentGame?.type === 'ice') {
                const isSpectator = currentGame.spectator === true;
                const presence = iceLobby?.presence ? Object.entries(iceLobby.presence) : [];
                const players = iceLobby?.players ? Object.entries(iceLobby.players) : [];
                const readySet = new Set(iceLobby?.readyPlayers ? Object.keys(iceLobby.readyPlayers) : []);
                const bettedSet = new Set(players.map(([id]) => id));
                const totalBank = players.reduce((s, [, p]) => s + p.bet, 0);
                const myPlayerData = iceLobby?.players?.[user?.id];
                const isWinner = gameStatus === 'finished' && iceLobby?.winner?.id === user?.id;
                const isLoser = gameStatus === 'finished' && iceLobby?.winner && iceLobby.winner.id !== user?.id;
                const statusText = () => {
                    if(isSpectator) return 'ðŸ‘ ÐÐ°Ð±Ð»ÑŽÐ´Ð°Ñ‚ÐµÐ»ÑŒ';
                    switch(gameStatus) {
                        case 'waiting': return `â³ ÐžÐ¶Ð¸Ð´Ð°Ð½Ð¸Ðµ Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð² (${presenceCount}/2+)`;
                        case 'open': return presenceCount >= 2 ? 'âœ… Ð¡Ñ‚Ð°Ð²ÐºÐ¸ Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚Ñ‹!' : 'â³ ÐžÐ¶Ð¸Ð´Ð°Ð½Ð¸Ðµ...';
                        case 'countdown': return `â° Ð¡Ñ‚Ð°Ñ€Ñ‚ Ñ‡ÐµÑ€ÐµÐ· ${timerRemaining} ÑÐµÐº!`;
                        case 'playing': return 'ðŸ”´ Ð˜Ð³Ñ€Ð° Ð¸Ð´Ñ‘Ñ‚!';
                        case 'finished': return isWinner ? 'ðŸ† Ð’Ñ‹ Ð¿Ð¾Ð±ÐµÐ´Ð¸Ð»Ð¸!' : `ðŸ† ÐŸÐ¾Ð±ÐµÐ´Ð¸Ð»: ${iceLobby?.winner?.name}`;
                        default: return '';
                    }
                };
                return (
                    <div className="min-h-screen bg-gradient-to-b from-blue-950 via-indigo-950 to-blue-900 pb-4">
                        <div className="max-w-lg mx-auto p-3">
                            <div className="flex justify-between items-center mb-3">
                                <div>
                                    <h1 className="text-xl font-bold text-white">â˜ƒï¸ Ð›ÐµÐ´ÑÐ½Ð¾Ð¹ ÐšÐ°Ñ‚Ð¾Ðº</h1>
                                    <div className="text-xs text-cyan-400">Ð›Ð¾Ð±Ð±Ð¸ #{currentGame.lobbyId}</div>
                                </div>
                                <button onClick={leaveIceLobby} className="bg-red-600/40 hover:bg-red-600 border border-red-500/50 px-3 py-1.5 rounded-xl font-bold transition text-sm">âœ• Ð’Ñ‹Ð¹Ñ‚Ð¸</button>
                            </div>
                            <div className={`rounded-xl p-2.5 mb-3 text-center font-bold border text-sm ${gameStatus === 'countdown' ? 'bg-yellow-500/20 border-yellow-500/50 animate-pulse' : gameStatus === 'open' ? 'bg-cyan-500/20 border-cyan-500/50' : gameStatus === 'playing' ? 'bg-red-500/20 border-red-500/50' : gameStatus === 'finished' ? 'bg-purple-500/20 border-purple-500/50' : 'bg-gray-700/50 border-gray-600/50'}`}>{statusText()}</div>
                            {gameStatus === 'countdown' && timerRemaining > 0 && (
                                <div className="text-center mb-3">
                                    <div className="text-6xl font-bold text-yellow-400 animate-pulse">{timerRemaining}</div>
                                    <div className="text-gray-400 text-xs">ÑÐµÐºÑƒÐ½Ð´ Ð´Ð¾ ÑÑ‚Ð°Ñ€Ñ‚Ð°</div>
                                </div>
                            )}
                            <div className="flex justify-center mb-4">
                                <div className={`ice-circle relative ${gameStatus === 'open' ? 'pulse-glow' : gameStatus === 'countdown' ? 'ready-glow' : ''}`}>
                                    <div className="absolute inset-0 opacity-10" style={{backgroundImage: 'radial-gradient(circle, #00d2ff 1px, transparent 1px)', backgroundSize: '20px 20px'}} />
                                    {(gameStatus === 'open' || gameStatus === 'countdown' || gameStatus === 'playing' || gameStatus === 'finished') && renderIceField()}
                                    {gameStatus === 'waiting' && <div className="absolute inset-0 flex items-center justify-center"><div className="text-5xl opacity-30">â“</div></div>}
                                    {gameStatus === 'playing' && <div className="ice-ball" style={{left: ballPos.x + '%', top: ballPos.y + '%'}} />}
                                    {gameStatus === 'finished' && iceLobby?.finalBall && <div className="ice-ball" style={{left: iceLobby.finalBall.x + '%', top: iceLobby.finalBall.y + '%', background: 'radial-gradient(circle at 30% 30%, #fff, #ffd700)', boxShadow: '0 0 25px #ffd700, 0 0 50px rgba(255,215,0,0.5)'}} />}
                                </div>
                            </div>
                            {!isSpectator && gameStatus === 'open' && (
                                <div className="glass rounded-xl p-3 mb-3 border border-cyan-500/30">
                                    {!hasBet ? (
                                        <>
                                            <p className="text-center text-cyan-300 font-bold mb-2 text-sm">ðŸ’° Ð’Ð°ÑˆÐ° ÑÑ‚Ð°Ð²ÐºÐ°</p>
                                            <div className="flex gap-2 mb-2">
                                                <input type="number" min="25" value={myBetInput} onChange={e => setMyBetInput(Math.max(25, Number(e.target.value)))} className="flex-1 bg-gray-800 border border-cyan-600 rounded-lg p-2.5 text-center text-lg text-white" />
                                                <button onClick={() => setMyBetInput(p => p + 25)} className="bg-cyan-700 hover:bg-cyan-600 px-3 rounded-lg font-bold transition text-sm">+25</button>
                                                <button onClick={() => setMyBetInput(p => p + 100)} className="bg-cyan-700 hover:bg-cyan-600 px-3 rounded-lg font-bold transition text-sm">+100</button>
                                            </div>
                                            <button onClick={placeBet} disabled={balance < myBetInput || myBetInput < 25} className="w-full bg-gradient-to-r from-cyan-600 to-blue-600 hover:from-cyan-500 hover:to-blue-500 py-2.5 rounded-xl font-bold disabled:opacity-50 transition text-sm">ÐŸÐ¾ÑÑ‚Ð°Ð²Ð¸Ñ‚ÑŒ {myBetInput}â­ï¸</button>
                                            <p className="text-center text-xs text-gray-500 mt-1">Ð‘Ð°Ð»Ð°Ð½Ñ: {balance.toFixed(0)}â­ï¸ | ÐœÐ¸Ð½: 25â­ï¸</p>
                                        </>
                                    ) : (
                                        <>
                                            <div className="text-center mb-2"><div className="text-green-400 font-bold">âœ… Ð¡Ñ‚Ð°Ð²ÐºÐ°: {myBet}â­ï¸</div></div>
                                            <div className="flex gap-2 mb-2">
                                                <input type="number" min="25" value={myBetInput} onChange={e => setMyBetInput(Math.max(25, Number(e.target.value)))} className="flex-1 bg-gray-800 border border-gray-600 rounded-lg p-2 text-center text-sm text-white" />
                                                <button onClick={changeBet} disabled={myBetInput === myBet} className="bg-orange-600 hover:bg-orange-500 px-3 rounded-lg font-bold transition text-xs disabled:opacity-40">Ð˜Ð·Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ</button>
                                            </div>
                                            <button onClick={toggleReady} className={`w-full py-3 rounded-xl font-bold transition ${isReady ? 'bg-gradient-to-r from-green-500 to-emerald-600 ready-glow text-white' : 'bg-gradient-to-r from-gray-600 to-gray-700 hover:from-gray-500 hover:to-gray-600 border border-gray-500'}`}>{isReady ? 'âœ… Ð“Ð¾Ñ‚Ð¾Ð²! (Ð½Ð°Ð¶Ð¼Ð¸Ñ‚Ðµ Ð´Ð»Ñ Ð¾Ñ‚Ð¼ÐµÐ½Ñ‹)' : 'ðŸ Ð“Ð¾Ñ‚Ð¾Ð² Ðº Ð¸Ð³Ñ€Ðµ'}</button>
                                            {bettingCount > 0 && <p className="text-center text-xs text-gray-400 mt-1">Ð“Ð¾Ñ‚Ð¾Ð²Ñ‹: {readyCount}/{bettingCount}</p>}
                                        </>
                                    )}
                                </div>
                            )}
                            {!isSpectator && gameStatus === 'waiting' && (
                                <div className="glass rounded-xl p-4 mb-3 text-center border border-gray-600/30">
                                    <div className="text-3xl mb-2 animate-bounce">â³</div>
                                    <div className="font-bold text-gray-300 text-sm">ÐžÐ¶Ð¸Ð´Ð°ÐµÐ¼ ÐµÑ‰Ñ‘ Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð²...</div>
                                    <div className="text-gray-500 text-xs mt-1">Ð¡Ñ‚Ð°Ð²ÐºÐ¸ Ð¾Ñ‚ÐºÑ€Ð¾ÑŽÑ‚ÑÑ ÐºÐ¾Ð³Ð´Ð° Ð·Ð°Ð¹Ð´ÑƒÑ‚ 2+ Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð²</div>
                                    <div className="flex justify-center gap-2 mt-2">
                                        {[1, 2].map(i => <div key={i} className={`w-8 h-8 rounded-full border-2 flex items-center justify-center text-sm ${i <= presenceCount ? 'border-cyan-400 bg-cyan-400/20 text-cyan-300' : 'border-gray-600 bg-gray-800 text-gray-600'}`}>{i <= presenceCount ? 'ðŸ‘¤' : 'â—‹'}</div>)}
                                    </div>
                                    <div className="text-cyan-400 text-xs mt-1">{presenceCount}/2</div>
                                </div>
                            )}
                            {!isSpectator && gameStatus === 'playing' && hasBet && (
                                <div className="glass rounded-xl p-3 mb-3 text-center border border-red-500/30">
                                    <div className="text-2xl animate-spin mb-1">ðŸŒ€</div>
                                    <div className="font-bold text-red-300 text-sm">Ð¨Ð°Ð¹Ð±Ð° ÐºÐ°Ñ‚Ð¸Ñ‚ÑÑ...</div>
                                    <div className="text-gray-400 text-xs">Ð¡Ñ‚Ð°Ð²ÐºÐ°: {myBet}â­ï¸ | Ð‘Ð°Ð½Ðº: {totalBank}â­ï¸</div>
                                </div>
                            )}
                            {isSpectator && (
                                <div className="glass rounded-xl p-3 mb-3 text-center border border-yellow-500/30">
                                    <div className="text-2xl mb-1">ðŸ‘</div>
                                    <div className="text-yellow-400 font-bold text-sm">Ð’Ñ‹ Ð½Ð°Ð±Ð»ÑŽÐ´Ð°Ñ‚ÐµÐ»ÑŒ</div>
                                    <div className="text-gray-500 text-xs">Ð˜Ð³Ñ€Ð° ÑƒÐ¶Ðµ Ð½Ð°Ñ‡Ð°Ð»Ð°ÑÑŒ</div>
                                </div>
                            )}
                            {isLoser && (
                                <div className="glass rounded-xl p-4 mb-3 text-center border border-gray-500/30">
                                    <div className="text-4xl mb-2">ðŸ˜”</div>
                                    <div className="font-bold text-gray-300">ÐŸÐ¾Ð±ÐµÐ´Ð¸Ð» {iceLobby?.winner?.name}</div>
                                    <div className="text-gray-400 text-xs mt-1 mb-3">Ð‘Ð°Ð½Ðº: {totalBank}â­ï¸ â†’ Ð¿Ð¾Ð±ÐµÐ´Ð¸Ñ‚ÐµÐ»ÑŒ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ð» {Math.floor(totalBank * 0.65)}â­ï¸</div>
                                    <button onClick={exitLobbyNonWinner} className="w-full bg-gray-600 hover:bg-gray-500 py-2.5 rounded-xl font-bold transition text-sm">Ð’Ñ‹Ð¹Ñ‚Ð¸ Ð¸Ð· Ð»Ð¾Ð±Ð±Ð¸</button>
                                </div>
                            )}
                            <div className="glass rounded-xl p-3 mb-3">
                                <div className="flex justify-between items-center mb-2">
                                    <h3 className="font-bold text-cyan-300 text-sm">ðŸ‘¥ Ð’ Ð»Ð¾Ð±Ð±Ð¸ ({presenceCount})</h3>
                                    <span className="text-xs text-gray-400">Ð‘Ð°Ð½Ðº: {totalBank}â­ï¸</span>
                                </div>
                                <div className="space-y-1.5 max-h-44 overflow-y-auto">
                                    {presence.map(([id, p]) => {
                                        const hasBetted = bettedSet.has(id);
                                        const isReadyP = readySet.has(id);
                                        const pData = hasBetted ? iceLobby.players[id] : null;
                                        const isMe = id === user.id;
                                        return (
                                            <div key={id} className={`flex items-center gap-2 p-2 rounded-lg border text-xs transition ${isReadyP ? 'player-row-ready' : hasBetted ? 'player-row-waiting' : 'player-row-presence bg-gray-800/30'}`}>
                                                <div className="w-2.5 h-2.5 rounded-full flex-shrink-0" style={{background: pData?.color || p.color || '#888'}} />
                                                <span className={`flex-1 font-medium ${isMe ? 'text-cyan-300' : 'text-white'}`}>{p.name}{isMe && ' (Ð’Ñ‹)'}</span>
                                                <div className="flex items-center gap-1.5">
                                                    {hasBetted && pData && <span className="text-yellow-400 font-bold">{pData.bet}â­ï¸</span>}
                                                    {isReadyP && <span className="text-green-400 font-bold">âœ…</span>}
                                                    {hasBetted && !isReadyP && <span className="text-yellow-500">â³</span>}
                                                    {!hasBetted && <span className="text-gray-500 italic">Ð² Ð»Ð¾Ð±Ð±Ð¸</span>}
                                                </div>
                                            </div>
                                        );
                                    })}
                                    {presence.length === 0 && <div className="text-gray-500 text-center py-3 text-xs">ÐÐ¸ÐºÐ¾Ð³Ð¾ Ð½ÐµÑ‚...</div>}
                                </div>
                            </div>
                            <div className="glass rounded-xl p-3">
                                <h3 className="font-bold text-center text-cyan-300 text-xs mb-2">ðŸŽ Ð’Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ñ‹Ðµ Ð±Ð¾Ð½ÑƒÑÑ‹</h3>
                                <div className="flex flex-wrap justify-center gap-1.5 text-xl">
                                    {['ðŸ§¸', 'ðŸ§¤', 'â„ï¸', 'ðŸ•', 'â˜ƒï¸', 'ðŸŽ–', 'â­ï¸', 'ðŸ§£', 'ðŸ”‘'].map((e, i) => <span key={i} className="bg-gray-800/60 p-1.5 rounded-lg border border-white/10">{e}</span>)}
                                </div>
                            </div>
                        </div>
                        {showVictoryBox && isWinner && (
                            <div className="fixed inset-0 bg-black/95 z-50 flex items-center justify-center p-4">
                                <div className="glass rounded-2xl p-6 max-w
