<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Step By Step Game</title>
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
<script>
tailwind.config = {
  darkMode: 'class',
  theme: {
    extend: { colors: { primary: '#6366f1', secondary: '#8b5cf6', accent: '#f59e0b', ice: '#00d2ff' } }
  }
}
</script>
<style>
@keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
@keyframes pulseGlow { 0%, 100% { box-shadow: 0 0 10px rgba(0,210,255,0.3); } 50% { box-shadow: 0 0 30px rgba(0,210,255,0.8); } }
.pulse-glow { animation: pulseGlow 2s ease-in-out infinite; }
.roulette-container { position: relative; width: 100%; height: 160px; overflow: hidden; background: rgba(0,0,0,0.4); border-radius: 16px; border: 2px solid rgba(255,255,255,0.1); margin: 20px 0; }
.roulette-inner { display: flex; position: absolute; left: 0; top: 20px; transition: transform 6.5s cubic-bezier(0.1, 0, 0.1, 1); will-change: transform; }
.roulette-item { width: 120px; height: 120px; flex-shrink: 0; margin: 0 8px; display: flex; flex-direction: column; align-items: center; justify-content: center; background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05)); border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); }
.roulette-item .emoji { font-size: 3.5rem; }
.roulette-item .name { font-size: 11px; opacity: 0.8; text-align: center; margin-top: 4px; }
.roulette-pointer { position: absolute; left: 50%; top: 0; bottom: 0; width: 4px; background: #ff4757; z-index: 20; transform: translateX(-50%); box-shadow: 0 0 20px #ff4757; }
.roulette-pointer::before { content: ''; position: absolute; top: -5px; left: 50%; transform: translateX(-50%); border-left: 10px solid transparent; border-right: 10px solid transparent; border-top: 15px solid #ff4757; }
.roulette-pointer::after { content: ''; position: absolute; bottom: -5px; left: 50%; transform: translateX(-50%); border-left: 10px solid transparent; border-right: 10px solid transparent; border-bottom: 15px solid #ff4757; }
.glass { background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); }
.line-through { text-decoration: line-through; opacity: 0.5; }
.fullscreen-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 100; overflow-y: auto; }
.ice-circle { width: 300px; height: 300px; border-radius: 50%; border: 4px solid rgba(255,255,255,0.2); position: relative; overflow: hidden; background: #f0f9ff; box-shadow: 0 0 20px rgba(0,210,255,0.2); }
.ice-ball { position: absolute; width: 30px; height: 30px; background: radial-gradient(circle at 30% 30%, #fff, #333); border-radius: 50%; box-shadow: 0 4px 10px rgba(0,0,0,0.5); z-index: 30; transform: translate(-50%, -50%); border: 1px solid rgba(0,0,0,0.2); }
.player-avatar-arena { position: absolute; width: 36px; height: 36px; border-radius: 50%; border: 2px solid white; overflow: hidden; transform: translate(-50%, -50%); z-index: 20; transition: all 0.3s ease; }
.case-cardboard { background: linear-gradient(135deg, #8B4513 0%, #D2691E 50%, #8B4513 100%); border: 3px solid #A0522D; }
.case-collector { background: linear-gradient(135deg, #DC143C 0%, #FF1493 50%, #8B008B 100%); border: 3px solid #FFD700; }
</style>
</head>
<body class="bg-gradient-to-br from-indigo-600 via-purple-600 to-pink-600 min-h-screen text-white overflow-x-hidden">
<div id="root"></div>
<script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script type="text/babel">
const { useState, useEffect, useRef } = React;
const firebaseConfig = {
  apiKey: "AIzaSyDZPRiByz69HQa8b7GFMCJeqq56J3Y-bOY",
  authDomain: "step-by-step-279df.firebaseapp.com",
  databaseURL: "https://step-by-step-279df-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "step-by-step-279df",
  storageBucket: "step-by-step-279df.firebasestorage.app",
  messagingSenderId: "302641152597",
  appId: "1:302641152597:web:6479b9ae03104666cd8adc"
};
if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
const db = firebase.database();
const TelegramWebApp = window.Telegram?.WebApp;
const BOT_TOKEN = '8325421899:AAHRdmMYdjJMXmAVIynDsQtpUNsSeKkaOis';
const ADMIN_WALLET = 'UQAWqaIPFSg81l9MlgAx0HBE9o3gpJMhk1dnyryKJXhWNHIc';
const CASE_REWARDS = {
  cardboard: [
    { id: 'stars_0_25', name: '0.25 ‚≠êÔ∏è', displayChance: '80%', realChance: 80, type: 'stars', value: 0.25, emoji: '‚≠êÔ∏è' },
    { id: 'stars_0_75', name: '0.75 ‚≠êÔ∏è', displayChance: '10%', realChance: 10, type: 'stars', value: 0.75, emoji: '‚≠êÔ∏è' },
    { id: 'stars_5', name: '5 ‚≠êÔ∏è', displayChance: '2%', realChance: 2, type: 'stars', value: 5, emoji: '‚≠êÔ∏è' },
    { id: 'bear', name: 'üß∏', displayChance: '1.5%', realChance: 1.5, type: 'item', sellPrice: 20, emoji: 'üß∏' }
  ],
  coal: [
    { id: 'stars_2_5', name: '2.5 ‚≠êÔ∏è', displayChance: '60%', realChance: 60, type: 'stars', value: 2.5, emoji: '‚≠êÔ∏è' },
    { id: 'stars_15', name: '15 ‚≠êÔ∏è', displayChance: '6%', realChance: 6, type: 'stars', value: 15, emoji: '‚≠êÔ∏è' },
    { id: 'material', name: '–ú–∞—Ç–µ—Ä–∏–∞–ª üß±', displayChance: '5%', realChance: 5, type: 'item', sellPrice: 40, emoji: 'üß±' }
  ],
  platinum: [
    { id: 'stars_50', name: '50 ‚≠êÔ∏è', displayChance: '35%', realChance: 35, type: 'stars', value: 50, emoji: '‚≠êÔ∏è' },
    { id: 'bday', name: 'B-day üóì', displayChance: '4%', realChance: 4, type: 'item', sellPrice: 150, emoji: 'üóì' }
  ],
  gold: [
    { id: 'stars_125', name: '125 ‚≠êÔ∏è', displayChance: '35%', realChance: 35, type: 'stars', value: 125, emoji: '‚≠êÔ∏è' },
    { id: 'clover', name: 'üçÄ Clover Pin', displayChance: '10%', realChance: 10, type: 'item', sellPrice: 200, emoji: 'üçÄ' }
  ],
  money: [
    { id: 'stars_150', name: '150 ‚≠êÔ∏è', displayChance: '45%', realChance: 45, type: 'stars', value: 150, emoji: '‚≠êÔ∏è' }
  ],
  elite: [
    { id: 'stars_200', name: '200 ‚≠êÔ∏è', displayChance: '75%', realChance: 75, type: 'stars', value: 200, emoji: '‚≠êÔ∏è' }
  ],
  diamond: [
    { id: 'stars_25', name: '25 ‚≠êÔ∏è', displayChance: '9%', realChance: 9, type: 'stars', value: 25, emoji: '‚≠êÔ∏è' }
  ],
  winter: [
    { id: 'stars_80', name: '80 ‚≠êÔ∏è', displayChance: '3.5%', realChance: 3.5, type: 'stars', value: 80, emoji: '‚≠êÔ∏è' }
  ],
  major: [
    { id: 'stars_1000', name: '1000 ‚≠êÔ∏è', displayChance: '25%', realChance: 25, type: 'stars', value: 1000, emoji: '‚≠êÔ∏è' }
  ],
  collector: [
    { id: 'bear_pro', name: 'üß∏ PRO', displayChance: '55%', realChance: 55, type: 'collectible', emoji: 'üß∏' }
  ]
};
const INITIAL_CASES = {
  cardboard: { id: 'cardboard', name: '–ö–∞—Ä—Ç–æ–Ω', emoji: 'üì¶', price: 3, color: 'from-amber-800 to-amber-900', locked: false, isNew: true, freeCount: 0 },
  coal: { id: 'coal', name: '–£–≥–æ–ª—ë–∫', emoji: 'ü™®', price: 22, originalPrice: 22, discountPrice: 20, color: 'from-gray-600 to-gray-800', locked: false, isNew: false, freeCount: 0 },
  platinum: { id: 'platinum', name: '–ü–ª–∞—Ç–∏–Ω–∞', emoji: 'üíé', price: 100, color: 'from-gray-300 to-gray-500', locked: false },
  gold: { id: 'gold', name: '–ó–æ–ª–æ—Ç–æ–π', emoji: 'üëë', price: 250, color: 'from-yellow-400 to-yellow-600', locked: false },
  money: { id: 'money', name: '–î–µ–Ω–µ–∂–Ω—ã–π', emoji: 'üíµ', price: 350, color: 'from-green-400 to-green-600', locked: false },
  elite: { id: 'elite', name: '–≠–ª–∏—Ç–∞', emoji: 'üéñ', price: 500, color: 'from-red-400 to-red-600', locked: false, isNew: false, freeCount: 0 },
  diamond: { id: 'diamond', name: '–ê–ª–º–∞–∑', emoji: 'üíé', price: 50, originalPrice: 50, discountPrice: 35, color: 'from-blue-400 to-blue-600', locked: false, isNew: false, freeCount: 0 },
  winter: { id: 'winter', name: '–ó–∏–º–Ω–∏–π', emoji: '‚òÉÔ∏è', price: 125, originalPrice: 150, discountPrice: 125, color: 'from-cyan-400 to-blue-500', locked: false, isNew: true, freeCount: 0 },
  major: { id: 'major', name: '–ú–∞–∂–æ—Ä', emoji: 'ü§¥', price: 800, color: 'from-purple-500 to-indigo-700', locked: true, isNew: false, freeCount: 0 },
  collector: { id: 'collector', name: '–ö–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–µ—Ä', emoji: 'üé©', price: 650, color: 'from-rose-600 to-pink-800', locked: true, isNew: true, freeCount: 0 }
};
const ICE_ARENA_PRIZES = [
  { id: 'bear', name: 'üß∏ –ú–∏—à–∫–∞', chance: 40, type: 'item', sellPrice: 20, emoji: 'üß∏' },
  { id: 'gloves', name: 'üß§ –í–∞—Ä–µ–∂–∫–∏', chance: 30, type: 'item', sellPrice: 50, emoji: 'üß§' },
  { id: 'winter_case', name: '‚òÉÔ∏è –ö–µ–π—Å –ó–∏–º–Ω–∏–π', chance: 4, type: 'case_free', caseType: 'winter', emoji: '‚òÉÔ∏è' },
  { id: 'stars_100', name: '100 ‚≠êÔ∏è', chance: 1, type: 'stars', value: 100, emoji: '100‚≠êÔ∏è' }
];
const STARS_PACKAGES = [ { stars: 50, price: 50 }, { stars: 250, price: 250 }, { stars: 500, price: 500 } ];
function App() {
  const [currentScreen, setCurrentScreen] = useState('cases');
  const [balance, setBalance] = useState(0);
  const [cases, setCases] = useState(INITIAL_CASES);
  const [inventory, setInventory] = useState([]);
  const [inventorySlots, setInventorySlots] = useState(5);
  const [user, setUser] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [totalDeposits, setTotalDeposits] = useState(0);
  // Roulette
  const [selectedCase, setSelectedCase] = useState(null);
  const [isSpinning, setIsSpinning] = useState(false);
  const [spinResult, setSpinResult] = useState(null);
  const [fakeItems, setFakeItems] = useState([]);
  const [rouletteOffset, setRouletteOffset] = useState(0);
  const [rouletteKey, setRouletteKey] = useState(0);
  const rouletteContainerRef = useRef(null);
  // Ice Arena
  const [currentGame, setCurrentGame] = useState(null);
  const [iceLobby, setIceLobby] = useState(null);
  const [gameStatus, setGameStatus] = useState('waiting');
  const [presenceCount, setPresenceCount] = useState(0);
  const [myBet, setMyBet] = useState(25);
  const [hasBet, setHasBet] = useState(false);
  const [isReady, setIsReady] = useState(false);
  const [ballPos, setBallPos] = useState({ x: 50, y: 50 });
  const [showPrizeModal, setShowPrizeModal] = useState(false);
  const [wonAmount, setWonAmount] = useState(0);
  const [wonItem, setWonItem] = useState(null);
  const [timerRemaining, setTimerRemaining] = useState(0);
  // Modals
  const [showTopUp, setShowTopUp] = useState(false);
  const [showWithdrawModal, setShowWithdrawModal] = useState(false);
  const [withdrawAmount, setWithdrawAmount] = useState('');
  const [tasks, setTasks] = useState({ subscribe: { completed: false }, deposit: { completed: false }, depositMajor: { completed: false } });
  useEffect(() => {
    const initApp = async () => {
      let userId = null;
      let userData = { name: '–ì–æ—Å—Ç—å', username: null, avatar: null };
      if (TelegramWebApp) {
        TelegramWebApp.ready();
        TelegramWebApp.expand();
        const tgUser = TelegramWebApp.initDataUnsafe?.user;
        if (tgUser) {
          userId = tgUser.id.toString();
          userData = { name: tgUser.first_name + (tgUser.last_name ? ' ' + tgUser.last_name : ''), username: tgUser.username ? '@' + tgUser.username : null, avatar: tgUser.photo_url || null };
        }
      }
      if (!userId) userId = localStorage.getItem('sbs_user_id') || 'guest_' + Date.now();
      localStorage.setItem('sbs_user_id', userId);
      try {
        const snap = await db.ref('users/' + userId).once('value');
        const data = snap.val();
        if (data) {
          setUser({ id: userId, ...userData, ...data });
          setBalance(data.balance || 0);
          setCases(data.cases || INITIAL_CASES);
          setInventory(data.inventory || []);
          setInventorySlots(data.inventorySlots || 5);
          setTotalDeposits(data.totalDeposits || 0);
          setTasks(data.tasks || { subscribe: { completed: false }, deposit: { completed: false }, depositMajor: { completed: false } });
        } else {
          const newUser = { balance: 0, cases: INITIAL_CASES, inventory: [], inventorySlots: 5, totalDeposits: 0, createdAt: Date.now() };
          await db.ref('users/' + userId).set(newUser);
          setUser({ id: userId, ...userData, ...newUser });
        }
      } catch (e) { console.error(e); }
      setIsLoading(false);
    };
    initApp();
  }, []);
  useEffect(() => {
    if (!user?.id || isLoading) return;
    const iv = setInterval(() => {
      db.ref('users/' + user.id).update({ balance, cases, inventory, inventorySlots, totalDeposits, tasks });
    }, 5000);
    return () => clearInterval(iv);
  }, [balance, cases, inventory, inventorySlots, totalDeposits, tasks, user?.id, isLoading]);
  // ICE ARENA SYNC
  useEffect(() => {
    if (!currentGame?.lobbyId || !user?.id) return;
    const lobbyRef = db.ref('iceLobbies/' + currentGame.lobbyId);
    
    // Register presence
    const presRef = lobbyRef.child('presence/' + user.id);
    presRef.set({ name: user.name, avatar: user.avatar, color: `hsl(${Math.random() * 360}, 70%, 50%)` });
    presRef.onDisconnect().remove();
    lobbyRef.on('value', snap => {
      const data = snap.val();
      if (!data) return;
      setIceLobby(data);
      setGameStatus(data.status || 'waiting');
      setPresenceCount(data.presence ? Object.keys(data.presence).length : 0);
      
      if (data.ballPosition) setBallPos(data.ballPosition);
      if (data.status === 'countdown' && data.timerEnd) {
        setTimerRemaining(Math.max(0, Math.ceil((data.timerEnd - Date.now()) / 1000)));
      }
      // Check if I bet
      if (data.players?.[user.id]) {
        setHasBet(true);
        setMyBet(data.players[user.id].bet);
        setIsReady(data.players[user.id].ready || false);
      } else {
        setHasBet(false);
        setIsReady(false);
      }
      // Show win modal
      if (data.status === 'finished' && data.winner?.id === user.id && !showPrizeModal) {
        setWonAmount(data.winner.starsWon);
        setWonItem(data.winner.reward);
        setShowPrizeModal(true);
      }
    });
    return () => {
      lobbyRef.off();
      presRef.remove();
    };
  }, [currentGame, user?.id]);
  const placeIceBet = async () => {
    if (!currentGame?.lobbyId) return;
    if (presenceCount < 2) { alert('–ù—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º 2 –∏–≥—Ä–æ–∫–∞ –≤ –ª–æ–±–±–∏!'); return; }
    
    const lobbyRef = db.ref('iceLobbies/' + currentGame.lobbyId);
    const snap = await lobbyRef.once('value');
    const currentData = snap.val();
    
    // Refund old bet if exists
    let newBalance = balance;
    if (currentData?.players?.[user.id]) {
      newBalance += currentData.players[user.id].bet;
    }
    if (newBalance < myBet) { alert('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∑–≤–µ–∑–¥!'); return; }
    newBalance -= myBet;
    setBalance(newBalance);
    await db.ref('users/' + user.id + '/balance').set(newBalance);
    await lobbyRef.child('players/' + user.id).update({
      id: user.id,
      name: user.name,
      avatar: user.avatar,
      bet: myBet,
      color: iceLobby.presence[user.id].color,
      ready: false,
      timestamp: Date.now()
    });
    setHasBet(true);
  };
  const toggleReady = async () => {
    if (!hasBet) return;
    const lobbyRef = db.ref('iceLobbies/' + currentGame.lobbyId);
    const nextReady = !isReady;
    await lobbyRef.child('players/' + user.id).update({ ready: nextReady });
    // Check if all players in presence who bet are ready
    const snap = await lobbyRef.once('value');
    const data = snap.val();
    const players = Object.values(data.players || {});
    const bettors = players.filter(p => p.bet > 0);
    
    if (bettors.length >= 2 && bettors.every(p => p.ready)) {
      // START COUNTDOWN
      const timerEnd = Date.now() + 10000;
      await lobbyRef.update({ status: 'countdown', timerEnd });
      setTimeout(() => startIceGame(lobbyRef), 10000);
    }
  };
  const startIceGame = async (lobbyRef) => {
    const snap = await lobbyRef.once('value');
    const data = snap.val();
    if (data.status !== 'countdown') return;
    await lobbyRef.update({ status: 'playing', ballPosition: { x: 50, y: 50 } });
    let x = 50, y = 50;
    let angle = Math.random() * Math.PI * 2;
    let speed = 2.5;
    let vx = Math.cos(angle) * speed;
    let vy = Math.sin(angle) * speed;
    const interval = setInterval(async () => {
      x += vx; y += vy;
      
      // Collision with circle border
      const dx = x - 50, dy = y - 50;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist >= 42) {
        // Reflect
        const nx = dx / dist, ny = dy / dist; // normal
        const dot = vx * nx + vy * ny;
        vx = (vx - 2 * dot * nx) * 0.98;
        vy = (vy - 2 * dot * ny) * 0.98;
        // Keep inside
        x = 50 + 41.5 * nx;
        y = 50 + 41.5 * ny;
      }
      // Friction
      vx *= 0.995; vy *= 0.995;
      await lobbyRef.child('ballPosition').set({ x, y });
      if (Math.abs(vx) < 0.1 && Math.abs(vy) < 0.1) {
        clearInterval(interval);
        finishIceGame(lobbyRef, x, y);
      }
    }, 40);
  };
  const finishIceGame = async (lobbyRef, fx, fy) => {
    const snap = await lobbyRef.once('value');
    const data = snap.val();
    const players = Object.values(data.players).sort((a,b) => a.timestamp - b.timestamp);
    const totalBank = players.reduce((s, p) => s + p.bet, 0);
    // Determine sector
    const dx = fx - 50, dy = fy - 50;
    let angle = Math.atan2(dy, dx) * 180 / Math.PI;
    if (angle < 0) angle += 360;
    let currentAngle = 0, winner = null;
    for (const p of players) {
      const sector = (p.bet / totalBank) * 360;
      if (angle >= currentAngle && angle < currentAngle + sector) {
        winner = p; break;
      }
      currentAngle += sector;
    }
    if (!winner) winner = players[0];
    const starsWon = Math.floor(totalBank * 0.4);
    const reward = ICE_ARENA_PRIZES[Math.floor(Math.random() * ICE_ARENA_PRIZES.length)];
    await lobbyRef.update({
      status: 'finished',
      winner: { id: winner.id, name: winner.name, starsWon, reward }
    });
  };
  const exitLobby = async () => {
    if (!currentGame?.lobbyId) return;
    const lobbyId = currentGame.lobbyId;
    setCurrentGame(null);
    setShowPrizeModal(false);
    // If I was the winner, reset the lobby for everyone
    if (iceLobby?.winner?.id === user.id) {
      // Add rewards
      const nb = balance + wonAmount;
      setBalance(nb);
      if (wonItem.type === 'stars') setBalance(prev => prev + wonItem.value);
      else if (wonItem.type === 'item') addToInventory(wonItem);
      else if (wonItem.type === 'case_free') setCases(prev => ({...prev, [wonItem.caseType]: {...prev[wonItem.caseType], freeCount: prev[wonItem.caseType].freeCount+1}}));
      
      await db.ref('iceLobbies/' + lobbyId).set({
        status: 'waiting',
        players: {},
        presence: {},
        ballPosition: { x: 50, y: 50 }
      });
    }
  };
  const renderArena = () => {
    if (!iceLobby?.players) return null;
    const players = Object.values(iceLobby.players).sort((a,b) => a.timestamp - b.timestamp);
    const totalBank = players.reduce((s, p) => s + p.bet, 0);
    
    let currentDeg = 0;
    const gradientParts = players.map(p => {
      const deg = (p.bet / totalBank) * 360;
      const part = `${p.color} ${currentDeg}deg ${currentDeg + deg}deg`;
      currentDeg += deg;
      return part;
    }).join(', ');
    return (
      <div className="ice-circle mx-auto relative overflow-hidden" style={{ background: totalBank > 0 ? `conic-gradient(${gradientParts})` : '#f0f9ff' }}>
        <div className="absolute inset-0 bg-white/20 pointer-events-none"></div>
        {/* Puck */}
        <div className="ice-ball" style={{ left: ballPos.x + '%', top: ballPos.y + '%' }}></div>
        {/* Avatars on sectors */}
        {players.map(p => {
          const perc = (p.bet / totalBank);
          const midAngle = (players.slice(0, players.indexOf(p)).reduce((s, x) => s + x.bet, 0) / totalBank) * 360 + (perc * 180);
          const rad = (midAngle - 90) * Math.PI / 180;
          const dist = 30; // offset from center
          return (
            <div key={p.id} className="player-avatar-arena" style={{ left: (50 + Math.cos(rad) * dist) + '%', top: (50 + Math.sin(rad) * dist) + '%', borderColor: p.ready ? '#4ade80' : 'white', transform: `translate(-50%, -50%) scale(${p.ready ? 1.2 : 1})` }}>
              {p.avatar ? <img src={p.avatar} className="w-full h-full object-cover" /> : <div className="bg-gray-400 w-full h-full"></div>}
            </div>
          );
        })}
      </div>
    );
  };
  // CASES ROULETTE
  const openCase = async (caseType) => {
    const price = cases[caseType].freeCount > 0 ? 0 : (cases[caseType].discountPrice || cases[caseType].price);
    if (balance < price && price > 0) { alert('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∑–≤–µ–∑–¥!'); return; }
    if (cases[caseType].freeCount > 0) {
      setCases(prev => ({...prev, [caseType]: {...prev[caseType], freeCount: prev[caseType].freeCount - 1}}));
    } else {
      setBalance(prev => prev - price);
    }
    setIsSpinning(true);
    setSelectedCase({...cases[caseType], id: caseType});
    setSpinResult(null);
    setRouletteKey(prev => prev + 1);
    const rewards = CASE_REWARDS[caseType];
    const rand = Math.random() * 100;
    let cum = 0, won = rewards[0];
    for (const r of rewards) { cum += r.realChance; if (rand <= cum) { won = r; break; } }
    const tape = [];
    for (let i = 0; i < 60; i++) tape.push(i === 50 ? won : rewards[Math.floor(Math.random() * rewards.length)]);
    setFakeItems(tape);
    setTimeout(() => {
      const itemWidth = 136;
      const containerWidth = rouletteContainerRef.current.offsetWidth;
      setRouletteOffset(-(50 * itemWidth + itemWidth/2 - containerWidth/2));
    }, 100);
    setTimeout(async () => {
      setSpinResult(won);
      setIsSpinning(false);
      if (won.type === 'stars') setBalance(prev => prev + won.value);
      else addToInventory(won);
    }, 6600);
  };
  const addToInventory = (item) => {
    if (inventory.length >= inventorySlots) { alert('–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å –ø–æ–ª–æ–Ω!'); return; }
    setInventory(prev => [...prev, {...item, uniqueId: Date.now()}]);
  };
  const sellItem = (item) => {
    if (confirm(`–ü—Ä–æ–¥–∞—Ç—å ${item.name} –∑–∞ ${item.sellPrice}‚≠êÔ∏è?`)) {
      setBalance(prev => prev + item.sellPrice);
      setInventory(prev => prev.filter(i => i.uniqueId !== item.uniqueId));
    }
  };
  return (
    <div className="min-h-screen pb-24">
      <header className="p-4 flex justify-between items-center glass sticky top-0 z-50">
        <h1 className="text-xl font-bold">Step By Step</h1>
        <button onClick={() => setShowTopUp(true)} className="bg-yellow-500 text-black px-4 py-2 rounded-full font-bold shadow-lg">{balance.toFixed(2)} ‚≠êÔ∏è</button>
      </header>
      <main className="p-4 max-w-md mx-auto">
        {currentScreen === 'cases' && (
          <div className="grid grid-cols-2 gap-4">
            {Object.values(cases).filter(c => !c.locked).map(c => (
              <div key={c.id} className={`glass rounded-xl p-4 relative ${c.id === 'cardboard' ? 'case-cardboard' : ''}`}>
                <div className="text-4xl text-center mb-2">{c.emoji}</div>
                <h3 className="font-bold text-center">{c.name}</h3>
                <p className="text-center text-sm">{c.freeCount > 0 ? '–ë–µ—Å–ø–ª–∞—Ç–Ω–æ' : `${c.price}‚≠êÔ∏è`}</p>
                <button onClick={() => setSelectedCase(c)} className="w-full mt-2 py-2 bg-indigo-600 rounded-lg font-bold">–û—Ç–∫—Ä—ã—Ç—å</button>
              </div>
            ))}
          </div>
        )}
        {currentScreen === 'games' && (
          <div className="space-y-4">
            <div className="glass p-6 rounded-2xl text-center border-ice/30 border">
              <h2 className="text-2xl font-bold text-ice mb-2">‚òÉÔ∏è –õ–µ–¥—è–Ω–æ–π –ö–∞—Ç–æ–∫</h2>
              <p className="text-sm opacity-70 mb-4">–°—Ç–∞–≤—å –∑–≤–µ–∑–¥—ã –∏ –≤—ã–∏–≥—Ä—ã–≤–∞–π 40% –±–∞–Ω–∫–∞ + —Å–µ–∫—Ä–µ—Ç–Ω—ã–π –ø—Ä–∏–∑!</p>
              <div className="grid grid-cols-5 gap-2">
                {[1,2,3,4,5].map(i => (
                  <button key={i} onClick={() => setCurrentGame({type:'ice', lobbyId: i})} className="bg-white/10 py-2 rounded-lg font-bold hover:bg-white/20 transition">#{i}</button>
                ))}
              </div>
            </div>
          </div>
        )}
        {currentScreen === 'profile' && (
          <div className="space-y-4">
            <div className="glass p-6 rounded-2xl text-center">
              <div className="w-20 h-20 bg-indigo-500 rounded-full mx-auto mb-2 flex items-center justify-center text-3xl">{user?.name[0]}</div>
              <h2 className="text-xl font-bold">{user?.name}</h2>
              <p className="opacity-60 text-sm">{user?.username || user?.id}</p>
            </div>
            <div className="glass p-4 rounded-2xl">
              <h3 className="font-bold mb-3">üéí –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å ({inventory.length}/{inventorySlots})</h3>
              <div className="grid grid-cols-5 gap-2">
                {[...Array(inventorySlots)].map((_, i) => (
                  <div key={i} className="aspect-square bg-white/5 rounded-lg flex items-center justify-center text-2xl" onClick={() => inventory[i] && sellItem(inventory[i])}>
                    {inventory[i]?.emoji || ''}
                  </div>
                ))}
              </div>
            </div>
          </div>
        )}
      </main>
      {/* ICE ARENA UI */}
      {currentGame?.type === 'ice' && (
        <div className="fixed inset-0 bg-black/95 z-[100] overflow-y-auto p-4 flex flex-col items-center">
          <div className="w-full max-w-md">
            <div className="flex justify-between items-center mb-6">
              <h2 className="text-2xl font-bold text-ice">–õ–æ–±–±–∏ #{currentGame.lobbyId}</h2>
              <button onClick={exitLobby} className="text-2xl">‚úï</button>
            </div>
            <div className="text-center mb-4">
              <div className="text-sm opacity-60">–°—Ç–∞—Ç—É—Å: <span className="text-white font-bold">{gameStatus === 'waiting' ? '–û–∂–∏–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–∫–æ–≤' : gameStatus === 'open' ? '–ü—Ä–∏–µ–º —Å—Ç–∞–≤–æ–∫' : gameStatus === 'countdown' ? '–û—Ç—Å—á–µ—Ç' : '–ò–≥—Ä–∞'}</span></div>
              <div className="text-sm opacity-60">–ò–≥—Ä–æ–∫–æ–≤: <span className="text-white font-bold">{presenceCount}</span></div>
            </div>
            {renderArena()}
            <div className="mt-8 space-y-4">
              {gameStatus === 'countdown' && (
                <div className="text-4xl font-bold text-yellow-400 text-center animate-pulse">–°–¢–ê–†–¢ –ß–ï–†–ï–ó {timerRemaining}</div>
              )}
              {gameStatus === 'waiting' && presenceCount < 2 && (
                <div className="bg-white/5 p-4 rounded-xl text-center">‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –≤—Ç–æ—Ä–æ–≥–æ –∏–≥—Ä–æ–∫–∞...</div>
              )}
              {(gameStatus === 'waiting' || gameStatus === 'open') && presenceCount >= 2 && (
                <div className="glass p-4 rounded-xl">
                  <div className="flex gap-2 mb-4">
                    <input type="number" value={myBet} onChange={e => setMyBet(Number(e.target.value))} className="flex-1 bg-black/40 border-white/20 border rounded-lg p-2 text-center" />
                    <button onClick={placeIceBet} className="bg-indigo-600 px-4 rounded-lg font-bold">–û–ö</button>
                  </div>
                  {hasBet && (
                    <button onClick={toggleReady} className={`w-full py-3 rounded-xl font-bold transition ${isReady ? 'bg-green-600' : 'bg-gray-600'}`}>
                      {isReady ? '‚úÖ –ì–û–¢–û–í' : 'üèÅ –ü–û–î–¢–í–ï–†–î–ò–¢–¨ –ì–û–¢–û–í–ù–û–°–¢–¨'}
                    </button>
                  )}
                </div>
              )}
              <div className="glass p-4 rounded-xl">
                <h4 className="text-sm font-bold mb-2 opacity-50">–£–ß–ê–°–¢–ù–ò–ö–ò:</h4>
                <div className="space-y-2">
                  {iceLobby?.players && Object.values(iceLobby.players).map(p => (
                    <div key={p.id} className="flex justify-between items-center p-2 bg-white/5 rounded-lg">
                      <div className="flex items-center gap-2">
                        <div className="w-3 h-3 rounded-full" style={{background: p.color}}></div>
                        <span className="text-sm">{p.name}</span>
                      </div>
                      <div className="flex items-center gap-2">
                        <span className="text-xs font-bold text-yellow-400">{p.bet}‚≠êÔ∏è</span>
                        {p.ready ? <span className="text-green-400 text-xs">READY</span> : <span className="text-gray-500 text-xs">WAIT</span>}
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          </div>
          {showPrizeModal && (
            <div className="fixed inset-0 bg-black/90 flex items-center justify-center p-6 z-[110]">
              <div className="glass p-8 rounded-3xl text-center max-w-sm w-full">
                <h2 className="text-3xl font-bold text-yellow-400 mb-2">–ü–û–ë–ï–î–ê! üèÜ</h2>
                <p className="mb-6 opacity-80">–í—ã –∑–∞—Ö–≤–∞—Ç–∏–ª–∏ –∫–∞—Ç–æ–∫!</p>
                <div className="text-6xl mb-4">üì¶</div>
                <div className="text-xl font-bold text-green-400 mb-1">+{wonAmount} ‚≠êÔ∏è</div>
                <div className="text-sm opacity-60 mb-8">–ë–æ–Ω—É—Å: {wonItem.emoji} {wonItem.name}</div>
                <button onClick={exitLobby} className="w-full bg-indigo-600 py-3 rounded-xl font-bold shadow-lg">–ó–ê–ë–†–ê–¢–¨ –ò –í–´–ô–¢–ò</button>
              </div>
            </div>
          )}
        </div>
      )}
      {/* ROULETTE MODAL */}
      {selectedCase && (
        <div className="fixed inset-0 bg-black/95 z-[200] flex items-center justify-center p-4">
          <div className="w-full max-w-lg" ref={rouletteContainerRef}>
            <div className="flex justify-between items-center mb-8">
              <h2 className="text-2xl font-bold">{selectedCase.emoji} {selectedCase.name}</h2>
              <button onClick={() => setSelectedCase(null)} className="text-3xl">‚úï</button>
            </div>
            
            <div key={rouletteKey} className="roulette-container">
              <div className="roulette-pointer"></div>
              <div className="roulette-inner" style={{ transform: `translateX(${rouletteOffset}px)` }}>
                {fakeItems.map((it, i) => (
                  <div key={i} className="roulette-item"><div className="emoji">{it.emoji}</div><div className="name">{it.name}</div></div>
                ))}
              </div>
            </div>
            {spinResult ? (
              <div className="text-center mt-8">
                <div className="text-3xl font-bold mb-4">–í–´–ò–ì–†–´–®: {spinResult.name}</div>
                <button onClick={() => setSelectedCase(null)} className="w-full bg-green-600 py-4 rounded-xl font-bold">–û–¢–õ–ò–ß–ù–û</button>
              </div>
            ) : (
              <button onClick={() => openCase(selectedCase.id)} disabled={isSpinning} className="w-full mt-8 bg-indigo-600 py-4 rounded-xl font-bold disabled:opacity-50">–ö–†–£–¢–ò–¢–¨</button>
            )}
          </div>
        </div>
      )}
      <nav className="fixed bottom-0 left-0 right-0 glass border-t border-white/10 p-2 z-40">
        <div className="max-w-md mx-auto flex justify-around">
          {['cases', 'games', 'profile'].map(s => (
            <button key={s} onClick={() => setCurrentScreen(s)} className={`flex flex-col items-center p-2 ${currentScreen === s ? 'text-indigo-400' : 'text-gray-400'}`}>
              <span className="text-xl">{s === 'cases' ? 'üéÅ' : s === 'games' ? 'üéÆ' : 'üë§'}</span>
              <span className="text-[10px] uppercase font-bold">{s}</span>
            </button>
          ))}
        </div>
      </nav>
    </div>
  );
}
ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>
